theory spdm_kex begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman, multiset
functions: fst/1, h/1, hkdf/3, hmac/2, pair/2, pk/1, sdec/2,
           senc/2, sid/2, sign/2, snd/1, true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true



/*
looping facts with injective instances:
  KeyExchangeInit/16, KeyExchangeResp/15, StateInit/11, StateResp/11
*/

restriction OneSharedPK:
  "∀ idI idR #i #j.
    ((OneSharePK( idI, idR ) @ #i) ∧ (OneSharePK( idI, idR ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction OneCertificate:
  "∀ id #i #j.
    ((OneCert( id ) @ #i) ∧ (OneCert( id ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction SingleRootCert:
  "∀ #i #j. ((RootOnce( ) @ #i) ∧ (RootOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction resetGetVersionInit:
  "∀ tid1 tid2 oidI oidR #i #j.
    (((StartThreadI( tid1, oidI, oidR ) @ #i) ∧
      (StartThreadI( tid2, oidI, oidR ) @ #j)) ∧
     (#i < #j)) ⇒
    (∀ #k.
      ((CurrentThreadI( tid1, oidI, oidR ) @ #k) ∧ (#j < #k)) ⇒ (⊥))"
  // safety formula

restriction updateKey:
  "∀ tid sid kuid1 kuid2 #i #j.
    (((KeyUpdate( tid, sid, kuid1 ) @ #i) ∧
      (KeyUpdate( tid, sid, kuid2 ) @ #j)) ∧
     (#i < #j)) ⇒
    (∀ #k. ((CurrentKey( tid, sid, kuid1 ) @ #k) ∧ (#j < #k)) ⇒ (⊥))"
  // safety formula

restriction singleKeyUpdate:
  "∀ tid sid kuid #i #j.
    ((OnlyOnce( tid, sid, kuid ) @ #i) ∧
     (OnlyOnce( tid, sid, kuid ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction rep_endSession:
  "∀ tid sid oidI oidR #i.
    (RespEndSession( sid, tid, oidI, oidR ) @ #i) ⇒
    (¬(∃ #j. (CurrentSesion( tid, sid ) @ #j) ∧ (#i < #j)))"
  // safety formula

restriction init_endSession:
  "∀ tid sid oidI oidR #i.
    (InitEndSession( sid, tid, oidI, oidR ) @ #i) ⇒
    (¬(∃ #j. (CurrentSesion( tid, sid ) @ #j) ∧ (#i < #j)))"
  // safety formula

restriction equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction inequality:
  "∀ x y #i. (Neq( x, y ) @ #i) ⇒ (¬(x = y))"
  // safety formula

rule (modulo E) CreateRootCert[color=#f9c74f]:
   [ Fr( ~ltk ) ]
  --[ CreateRootCert( ~ltk ), RootOnce( ) ]->
   [ !RootCert( ~ltk ), !TrustAnchor( pk(~ltk) ), Out( pk(~ltk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) createDevice:
   [
   Fr( ~oid ), In( capabilities ), Fr( ~measure ), In( <v1, v2> ),
   In( <a1, a2> )
   ]
  --[
  IsValidVersion( v1 ), IsValidVersion( v2 ), IsValidAlgo( a1 ),
  IsValidAlgo( a2 )
  ]->
   [
   !Device( ~oid, <v1, v2>, capabilities, <a1, a2> ),
   !Measurement( ~oid, ~measure ), Out( ~oid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) sharePSK:
   [
   !Device( ~oid1, V1, ('PSK'+C1), A1 ),
   !Device( ~oid2, V2, ('PSK'+C2), A2 ), Fr( ~key )
   ]
  -->
   [ !PSK( ~oid1, ~oid2, ~key ), !PSK( ~oid2, ~oid1, ~key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) sharePK:
   [
   Fr( ~ltk1 ), Fr( ~ltk2 ), !Device( ~oid1, V1, C1, A1 ),
   !Device( ~oid2, V2, C2, A2 )
   ]
  --[
  OneSharePK( ~oid1, ~oid2 ), OneSharePK( ~oid2, ~oid1 ),
  SecretLtk( ~ltk1 ), SecretLtk( ~ltk2 )
  ]->
   [
   !SharedPK( ~oid1, ~oid2, pk(~ltk1), pk(~ltk2) ),
   !LTK( ~oid1, ~ltk1 ), !LTK( ~oid2, ~ltk2 ), Out( pk(~ltk1) ),
   Out( pk(~ltk2) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) A_getCertHonest:
   [ !Device( ~oid, V, C, A ), !RootCert( ~rootkey ), Fr( ~ltk ) ]
  --[ OneCert( ~oid ), Honest( ~oid, ~ltk, pk(~ltk) ) ]->
   [
   !LTK( ~oid, ~ltk ), !PK( ~oid, pk(~ltk) ),
   !Cert( ~oid, pk(~ltk), sign(<~oid, pk(~ltk)>, ~rootkey) ),
   Out( <pk(~ltk), sign(<~oid, pk(~ltk)>, ~rootkey)> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) getCertAttacker:
   [ In( ~oid ), !RootCert( ~rootkey ), Fr( ~ltk ) ]
  --[ Attacker( ~oid, ~ltk, pk(~ltk) ) ]->
   [
   !PK( ~oid, pk(~ltk) ),
   Out( <~ltk, ~oid, sign(<~oid, pk(~ltk)>, ~rootkey)> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_Version_FirstRequest[color=#2ec4b6]:
   [
   !Device( ~oid, V, C, A ), !Device( ~oidR, VR, CR, AR ), Fr( ~tid )
   ]
  --[
  Channel( ~oid, ~oidR ), StartThreadI( ~tid, ~oid, ~oidR ),
  CurrentThreadI( ~tid, ~oid, ~oidR ),
  VCATranscriptI( (<'Algorithms', 'NULL'>+<'Capabilities', 'NULL'>+
                   <'Get_Capabilities', 'NULL'>+<'Get_Version', 'Get_Version', '1'>+
                   <'Negotiate_Algorithms', 'NULL'>+<'Version', 'NULL'>)
  )
  ]->
   [
   StateInit( ~tid, ~oid, ~oidR, '1', 'NULL', <V, C, A>,
              (<'Algorithms', 'NULL'>+<'Capabilities', 'NULL'>+
               <'Get_Capabilities', 'NULL'>+<'Get_Version', 'Get_Version', '1'>+
               <'Negotiate_Algorithms', 'NULL'>+<'Version', 'NULL'>),
              'NULL', 'NULL', 'NULL', 'START_GETVERSION'
   ),
   Out( <'Get_Version', '1'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_Version_FirstResponse[color=#2ec4b6]:
   [
   !Device( ~oid, V, C, A ), !Device( ~oidI, VI, CI, AI ), Fr( ~tid ),
   In( <'Get_Version', '1'> )
   ]
  --[
  StartThreadR( ~tid, ~oidI, ~oid ),
  CurrentThreadR( ~tid, ~oidI, ~oid ),
  VCATranscriptR( (<'Algorithms', 'NULL'>+<'Capabilities', 'NULL'>+
                   <'Get_Capabilities', 'NULL'>+<'Get_Version', 'Get_Version', '1'>+
                   <'Negotiate_Algorithms', 'NULL'>+<'Version', 'Version', V>)
  )
  ]->
   [
   StateResp( ~tid, ~oidI, ~oid, '1', 'NULL', <V, C, A>,
              (<'Algorithms', 'NULL'>+<'Capabilities', 'NULL'>+
               <'Get_Capabilities', 'NULL'>+<'Get_Version', 'Get_Version', '1'>+
               <'Negotiate_Algorithms', 'NULL'>+<'Version', 'Version', V>),
              'NULL', 'NULL', 'NULL', 'RESP_GETVERSION'
   ),
   Out( <'Version', V> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_Capabilities_Request[color=#f9844a]:
   [
   StateInit( ~tid, ~oid, ~oidR, '1', 'NULL', <V, C, A>,
              (VCATranscript+<'Get_Capabilities', trash2>+<'Version', trash1>),
              optionsTranscript, 'NULL', 'NULL', 'START_GETVERSION'
   ),
   In( <'Version', VR> ), In( vx )
   ]
  --[
  IsIn( vx, V ), IsIn( vx, VR ), Version( ~tid, vx ),
  CurrentThreadI( ~tid, ~oid, ~oidR ),
  VCATranscriptI( (VCATranscript+<'Get_Capabilities', trash2>+
                   <'Version', trash1>)
  )
  ]->
   [
   StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
              (VCATranscript+<'Get_Capabilities', 'Get_Capabilities', vx, C>+
               <'Version', 'Version', VR>),
              optionsTranscript, 'NULL', 'NULL', 'START_GETCAP'
   ),
   Out( <'Get_Capabilities', vx, C> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_Capabilities_Response[color=#f9844a]:
   [
   StateResp( ~tid, ~oidI, ~oid, '1', 'NULL', <V, C, A>,
              (VCATranscript+<'Capabilities', 'NULL'>+
               <'Get_Capabilities', 'NULL'>),
              optionsTranscript, 'NULL', 'NULL', 'RESP_GETVERSION'
   ),
   In( <'Get_Capabilities', vx, CI> )
   ]
  --[
  Version( ~tid, vx ), CurrentThreadR( ~tid, ~oidI, ~oid ),
  VCATranscriptR( (VCATranscript+<'Capabilities', 'NULL'>+
                   <'Get_Capabilities', 'NULL'>)
  )
  ]->
   [
   StateResp( ~tid, ~oidI, ~oid, vx, 'NULL', <V, C, A>,
              (VCATranscript+<'Capabilities', 'Capabilities', vx, C>+
               <'Get_Capabilities', 'Get_Capabilities', vx, CI>),
              optionsTranscript, 'NULL', 'NULL', 'RESP_GETCAPABILITIES'
   ),
   Out( <'Capabilities', vx, C> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_Algorithms_Request[color=#f9844a]:
   [
   StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
              (VCATranscript+<'Capabilities', 'NULL'>+
               <'Negotiate_Algorithms', 'NULL'>),
              optionsTranscript, 'NULL', 'NULL', 'START_GETCAP'
   ),
   In( <'Capabilities', vx, CR> )
   ]
  --[
  Version( ~tid, vx ), CurrentThreadI( ~tid, ~oid, ~oidR ),
  VCATranscriptI( (VCATranscript+<'Capabilities', 'NULL'>+
                   <'Negotiate_Algorithms', 'NULL'>)
  )
  ]->
   [
   StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
              (VCATranscript+<'Capabilities', 'Capabilities', vx, CR>+
               <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, A>),
              optionsTranscript, 'NULL', 'NULL', 'START_GETALGORITHMS'
   ),
   Out( <'Negotiate_Algorithms', vx, A> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_Algorithms_Response[color=#f9844a]:
   [
   StateResp( ~tid, ~oidI, ~oid, vx, 'NULL', <V, C, A>,
              (VCATranscript+<'Algorithms', 'NULL'>+
               <'Negotiate_Algorithms', 'NULL'>),
              optionsTranscript, 'NULL', 'NULL', 'RESP_GETCAPABILITIES'
   ),
   In( <'Negotiate_Algorithms', vx, AI> ), In( ax )
   ]
  --[
  IsIn( ax, AI ), IsIn( ax, A ), Version( ~tid, vx ),
  CurrentThreadR( ~tid, ~oidI, ~oid ),
  RespReachVCA( ~tid, ~oidI, ~oid ),
  VCATranscriptR( (VCATranscript+<'Algorithms', 'NULL'>+
                   <'Negotiate_Algorithms', 'NULL'>)
  )
  ]->
   [
   StateResp( ~tid, ~oidI, ~oid, vx, ax, <V, C, A>,
              (VCATranscript+<'Algorithms', 'Algorithms', vx, ax>+
               <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, AI>),
              optionsTranscript, 'NULL', 'NULL', 'IDLE'
   ),
   Out( <'Algorithms', vx, ax> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_Algorithms_ProcessResponse[color=#f9844a]:
   [
   StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
              (VCATranscript+<'Algorithms', 'NULL'>), optionsTranscript, 'NULL',
              'NULL', 'START_GETALGORITHMS'
   ),
   In( <'Algorithms', vx, ax> )
   ]
  --[
  Version( ~tid, vx ), CurrentThreadI( ~tid, ~oid, ~oidR ),
  VCATranscriptI( (VCATranscript+<'Algorithms', 'NULL'>) ),
  InitReachVCA( ~tid, ~oid, ~oidR )
  ]->
   [
   StateInit( ~tid, ~oid, ~oidR, vx, ax, <V, C, A>,
              (VCATranscript+<'Algorithms', 'Algorithms', vx, ax>),
              optionsTranscript, 'NULL', 'NULL', 'IDLE'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_Spawn_new_PK_Session:
   [
   StateInit( ~tidI, ~oidI, ~oidR, version, axI, <VI, CI, AI>,
              VCATranscriptI, optionsTranscriptI, somePKR, digestR, 'IDLE'
   ),
   In( <in_pkR, sign(<~oidR, in_pkR>, ~rootkey)> ),
   !RootCert( ~rootkey ), Fr( ~sid )
   ]
  --[
  Version( ~tidI, version ), CurrentThreadI( ~tidI, ~oidI, ~oidR ),
  IStartKEX( ~sid, ~tidI, ~oidI, ~oidR ),
  KETranscriptI( (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                  <'Get_Key_Exchange', 'NULL'>+<'Key_Exchange_Resp', 'NULL'>)
  ),
  IStoredCert( ~tidI, ~oidI, ~oidR, in_pkR,
               sign(<~oidR, in_pkR>, ~rootkey)
  )
  ]->
   [
   StateInit( ~tidI, ~oidI, ~oidR, version, axI, <VI, CI, AI>,
              VCATranscriptI, optionsTranscriptI, in_pkR,
              h(sign(<~oidR, in_pkR>, ~rootkey)), 'IDLE'
   ),
   KeyExchangeInit( ~sid, ~tidI, ~oidI, ~oidR, in_pkR,
                    h(sign(<~oidR, in_pkR>, ~rootkey)), version, VCATranscriptI,
                    (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                     <'Get_Key_Exchange', 'NULL'>+<'Key_Exchange_Resp', 'NULL'>),
                    'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) R_Spawn_new_PK_Session:
   [
   StateResp( ~tidR, ~oidI, ~oidR, version, axR, <VR, CR, AR>,
              VCATranscriptR, optionsTranscriptR, pubKI, digestI, 'IDLE'
   ),
   Fr( ~sid )
   ]
  --[
  Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
  RStartKEX( ~sid, ~tidR, ~oidI, ~oidR ),
  KETranscriptR( (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                  <'Get_Key_Exchange', 'NULL'>+<'Key_Exchange_Resp', 'NULL'>)
  )
  ]->
   [
   StateResp( ~tidR, ~oidI, ~oidR, version, axR, <VR, CR, AR>,
              VCATranscriptR, optionsTranscriptR, pubKI, digestI, 'IDLE'
   ),
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, pubKI, digestI,
                    version, VCATranscriptR,
                    (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                     <'Get_Key_Exchange', 'NULL'>+<'Key_Exchange_Resp', 'NULL'>),
                    'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) I_KE_Request[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, pkR, digestR, version,
                    VCATrancriptI, (messageTranscript+<'Get_Key_Exchange', gke>),
                    'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
   ),
   Fr( ~nonce ), Fr( ~newPrivKey ), Fr( ~initSessionId )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  StartKeyExchange( ~sid, ~tid, ~oidI, ~oidR, ~initSessionId ),
  KETranscriptI( (messageTranscript+<'Get_Key_Exchange', gke>) )
  ]->
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, pkR, digestR, version,
                    VCATrancriptI,
                    (messageTranscript+
                     <'Get_Key_Exchange', 'Get_Key_Exchange', version, ~initSessionId, 
                      ~nonce, 'g'^~newPrivKey>
                    ),
                    ~newPrivKey, ~initSessionId, 'NULL', 'NULL', 'NULL', 'NULL',
                    'WAIT_KEY_RESP'
   ),
   Out( <'Get_Key_Exchange', version, ~initSessionId, ~nonce, 
         'g'^~newPrivKey>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_KE_Response[color=#43aa8b]:
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, somedigestI,
                    version, VCATrancript,
                    (messageTranscript+<'Get_Key_Exchange', gke>+
                     <'Key_Exchange_Resp', ker>),
                    'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
   ),
   !Cert( ~oidR, pk(~ltkR), certR ), Fr( ~respNonce ),
   Fr( ~respSessionId ), Fr( ~respPrivKey ),
   In( <'Get_Key_Exchange', version, initSessionId, nonce, publicKey>
   )
   ]
  --[
  Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
  SendKEResponse( ~sid, ~tidR, ~oidI, ~oidR, ~respSessionId ),
  RunningBeforeFinish( ~sid, ~tidR, ~oidI, ~oidR, pk(~ltkR) ),
  SessionId( ~tidR, ~sid, sid(initSessionId, ~respSessionId) ),
  DHOutputResp( ~sid, ~tidR, ~oidI, ~oidR, ~ltkR,
                publicKey^~respPrivKey
  ),
  KETranscriptR( (messageTranscript+<'Get_Key_Exchange', gke>+
                  <'Key_Exchange_Resp', ker>)
  )
  ]->
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, somedigestI,
                    version, VCATrancript,
                    (messageTranscript+
                     <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                      nonce, publicKey>+
                     <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                      ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                      sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                              h(certR), 
                              (messageTranscript+
                               <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                                nonce, publicKey>+
                               <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                                'NULL', 'NULL'>
                              )
                             >),
                           ~ltkR), 
                      hmac(h(<VCATrancript, h(certR), 
                              (messageTranscript+
                               <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                                nonce, publicKey>+
                               <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                                sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                        h(certR), 
                                        (messageTranscript+
                                         <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                          initSessionId, nonce, publicKey>+
                                         <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                          ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                          'g'^~respPrivKey, 'NULL', 'NULL'>
                                        )
                                       >),
                                     ~ltkR), 
                                'NULL'>
                              )
                             >),
                           hkdf(hkdf(hmac(publicKey^~respPrivKey, 'salt_o'),
                                     h(<VCATrancript, h(certR), 
                                        (messageTranscript+
                                         <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                          initSessionId, nonce, publicKey>+
                                         <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                          ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                          'g'^~respPrivKey, 
                                          sign(h(<version, 'Key_Exchange_Resp_Signing', 
                                                  VCATrancript, h(certR), 
                                                  (messageTranscript+
                                                   <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                    version, initSessionId, nonce, publicKey>+
                                                   <'Key_Exchange_Resp', 'Key_Exchange_Resp', 
                                                    version, ~respSessionId, 'No_Mutual_auth', 
                                                    ~respNonce, 'g'^~respPrivKey, 'NULL', 'NULL'>
                                                  )
                                                 >),
                                               ~ltkR), 
                                          'NULL'>
                                        )
                                       >),
                                     'resp_hs_data'),
                                version, 'finished'))
                     >
                    ),
                    'NULL', hmac(publicKey^~respPrivKey, 'salt_o'),
                    hkdf(hkdf(hmac(publicKey^~respPrivKey, 'salt_o'),
                              h(<VCATrancript, h(certR), 
                                 (messageTranscript+
                                  <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                                   nonce, publicKey>+
                                  <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                   ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                                   sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                           h(certR), 
                                           (messageTranscript+
                                            <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                             initSessionId, nonce, publicKey>+
                                            <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                             ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                             'g'^~respPrivKey, 'NULL', 'NULL'>
                                           )
                                          >),
                                        ~ltkR), 
                                   'NULL'>
                                 )
                                >),
                              'resp_hs_data'),
                         version, 'finished'),
                    hkdf(hkdf(hmac(publicKey^~respPrivKey, 'salt_o'),
                              h(<VCATrancript, h(certR), 
                                 (messageTranscript+
                                  <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                                   nonce, publicKey>+
                                  <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                   ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                                   sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                           h(certR), 
                                           (messageTranscript+
                                            <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                             initSessionId, nonce, publicKey>+
                                            <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                             ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                             'g'^~respPrivKey, 'NULL', 'NULL'>
                                           )
                                          >),
                                        ~ltkR), 
                                   'NULL'>
                                 )
                                >),
                              'init_hs_data'),
                         version, 'finished'),
                    sid(initSessionId, ~respSessionId), 'AFTER_KE'
   ),
   Out( <'Key_Exchange_Resp', version, ~respSessionId, 
         'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
         sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                 h(certR), 
                 (messageTranscript+
                  <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                   nonce, publicKey>+
                  <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                   ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                   'NULL', 'NULL'>
                 )
                >),
              ~ltkR), 
         hmac(h(<VCATrancript, h(certR), 
                 (messageTranscript+
                  <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                   nonce, publicKey>+
                  <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                   ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                   sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                           h(certR), 
                           (messageTranscript+
                            <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                             nonce, publicKey>+
                            <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                             ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                             'NULL', 'NULL'>
                           )
                          >),
                        ~ltkR), 
                   'NULL'>
                 )
                >),
              hkdf(hkdf(hmac(publicKey^~respPrivKey, 'salt_o'),
                        h(<VCATrancript, h(certR), 
                           (messageTranscript+
                            <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                             nonce, publicKey>+
                            <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                             ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                             sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                     h(certR), 
                                     (messageTranscript+
                                      <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                       initSessionId, nonce, publicKey>+
                                      <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                       ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                       'g'^~respPrivKey, 'NULL', 'NULL'>
                                     )
                                    >),
                                  ~ltkR), 
                             'NULL'>
                           )
                          >),
                        'resp_hs_data'),
                   version, 'finished'))
        >
   )
   ]

  /*
  rule (modulo AC) R_KE_Response[color=#43aa8b]:
     [
     KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, somedigestI,
                      version, VCATrancript,
                      (messageTranscript+<'Get_Key_Exchange', gke>+
                       <'Key_Exchange_Resp', ker>),
                      'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
     ),
     !Cert( ~oidR, pk(~ltkR), certR ), Fr( ~respNonce ),
     Fr( ~respSessionId ), Fr( ~respPrivKey ),
     In( <'Get_Key_Exchange', version, initSessionId, nonce, publicKey>
     )
     ]
    --[
    Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
    SendKEResponse( ~sid, ~tidR, ~oidI, ~oidR, ~respSessionId ),
    RunningBeforeFinish( ~sid, ~tidR, ~oidI, ~oidR, pk(~ltkR) ),
    SessionId( ~tidR, ~sid, sid(initSessionId, ~respSessionId) ),
    DHOutputResp( ~sid, ~tidR, ~oidI, ~oidR, ~ltkR, z ),
    KETranscriptR( (messageTranscript+<'Get_Key_Exchange', gke>+
                    <'Key_Exchange_Resp', ker>)
    )
    ]->
     [
     KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, somedigestI,
                      version, VCATrancript,
                      (messageTranscript+
                       <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                        nonce, publicKey>+
                       <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                        ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                        sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                h(certR), 
                                (messageTranscript+
                                 <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                                  nonce, publicKey>+
                                 <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                  ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                                  'NULL', 'NULL'>
                                )
                               >),
                             ~ltkR), 
                        hmac(h(<VCATrancript, h(certR), 
                                (messageTranscript+
                                 <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                                  nonce, publicKey>+
                                 <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                  ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                                  sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                          h(certR), 
                                          (messageTranscript+
                                           <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                            initSessionId, nonce, publicKey>+
                                           <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                            ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                            'g'^~respPrivKey, 'NULL', 'NULL'>
                                          )
                                         >),
                                       ~ltkR), 
                                  'NULL'>
                                )
                               >),
                             hkdf(hkdf(hmac(z, 'salt_o'),
                                       h(<VCATrancript, h(certR), 
                                          (messageTranscript+
                                           <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                            initSessionId, nonce, publicKey>+
                                           <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                            ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                            'g'^~respPrivKey, 
                                            sign(h(<version, 'Key_Exchange_Resp_Signing', 
                                                    VCATrancript, h(certR), 
                                                    (messageTranscript+
                                                     <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                      version, initSessionId, nonce, publicKey>+
                                                     <'Key_Exchange_Resp', 'Key_Exchange_Resp', 
                                                      version, ~respSessionId, 'No_Mutual_auth', 
                                                      ~respNonce, 'g'^~respPrivKey, 'NULL', 'NULL'>
                                                    )
                                                   >),
                                                 ~ltkR), 
                                            'NULL'>
                                          )
                                         >),
                                       'resp_hs_data'),
                                  version, 'finished'))
                       >
                      ),
                      'NULL', hmac(z, 'salt_o'),
                      hkdf(hkdf(hmac(z, 'salt_o'),
                                h(<VCATrancript, h(certR), 
                                   (messageTranscript+
                                    <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                     initSessionId, nonce, publicKey>+
                                    <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                     ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                     'g'^~respPrivKey, 
                                     sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                             h(certR), 
                                             (messageTranscript+
                                              <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                               initSessionId, nonce, publicKey>+
                                              <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                               ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                               'g'^~respPrivKey, 'NULL', 'NULL'>
                                             )
                                            >),
                                          ~ltkR), 
                                     'NULL'>
                                   )
                                  >),
                                'resp_hs_data'),
                           version, 'finished'),
                      hkdf(hkdf(hmac(z, 'salt_o'),
                                h(<VCATrancript, h(certR), 
                                   (messageTranscript+
                                    <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                     initSessionId, nonce, publicKey>+
                                    <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                     ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                     'g'^~respPrivKey, 
                                     sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                             h(certR), 
                                             (messageTranscript+
                                              <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                               initSessionId, nonce, publicKey>+
                                              <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                               ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                               'g'^~respPrivKey, 'NULL', 'NULL'>
                                             )
                                            >),
                                          ~ltkR), 
                                     'NULL'>
                                   )
                                  >),
                                'init_hs_data'),
                           version, 'finished'),
                      sid(initSessionId, ~respSessionId), 'AFTER_KE'
     ),
     Out( <'Key_Exchange_Resp', version, ~respSessionId, 
           'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
           sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                   h(certR), 
                   (messageTranscript+
                    <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                     nonce, publicKey>+
                    <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                     ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                     'NULL', 'NULL'>
                   )
                  >),
                ~ltkR), 
           hmac(h(<VCATrancript, h(certR), 
                   (messageTranscript+
                    <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                     nonce, publicKey>+
                    <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                     ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                     sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                             h(certR), 
                             (messageTranscript+
                              <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                               nonce, publicKey>+
                              <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                               ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                               'NULL', 'NULL'>
                             )
                            >),
                          ~ltkR), 
                     'NULL'>
                   )
                  >),
                hkdf(hkdf(hmac(z, 'salt_o'),
                          h(<VCATrancript, h(certR), 
                             (messageTranscript+
                              <'Get_Key_Exchange', 'Get_Key_Exchange', version, initSessionId, 
                               nonce, publicKey>+
                              <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                               ~respSessionId, 'No_Mutual_auth', ~respNonce, 'g'^~respPrivKey, 
                               sign(h(<version, 'Key_Exchange_Resp_Signing', VCATrancript, 
                                       h(certR), 
                                       (messageTranscript+
                                        <'Get_Key_Exchange', 'Get_Key_Exchange', version, 
                                         initSessionId, nonce, publicKey>+
                                        <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                         ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                         'g'^~respPrivKey, 'NULL', 'NULL'>
                                       )
                                      >),
                                    ~ltkR), 
                               'NULL'>
                             )
                            >),
                          'resp_hs_data'),
                     version, 'finished'))
          >
     )
     ]
    variants (modulo AC)
    1. ~respPrivKey
             = ~respPrivKey.40
       publicKey
             = publicKey.51
       z     = publicKey.51^~respPrivKey.40
    
    2. ~respPrivKey
             = ~respPrivKey.51
       publicKey
             = z.73^inv(~respPrivKey.51)
       z     = z.73
    
    3. ~respPrivKey
             = ~respPrivKey.442
       publicKey
             = x.877^x.878
       z     = x.877^(~respPrivKey.442*x.878)
    
    4. ~respPrivKey
             = ~respPrivKey.453
       publicKey
             = x.899^inv((~respPrivKey.453*x.900))
       z     = x.899^inv(x.900)
    
    5. ~respPrivKey
             = ~respPrivKey.453
       publicKey
             = x.899^(x.900*inv(~respPrivKey.453))
       z     = x.899^x.900
    
    6. ~respPrivKey
             = ~respPrivKey.454
       publicKey
             = x.900^(x.901*inv((~respPrivKey.454*x.902)))
       z     = x.900^(x.901*inv(x.902))
  */

rule (modulo E) I_KE_ProcessAndVerify[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATrancriptI,
                    (messageTranscript+<'Key_Exchange_Resp', rsp>), ~privKey,
                    ~initSessionId, 'NULL', 'NULL', 'NULL', 'NULL', 'WAIT_KEY_RESP'
   ),
   In( <'Key_Exchange_Resp', version, respSessionId, 
        'No_Mutual_auth', respNonce, respPublicKey, 
        sign(h(K1_Transcript_Sign), ~ltkR), 
        hmac(h(K1_Transcript_HMAC), in_finished_key)>
   )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, sid(~initSessionId, respSessionId) ),
  ReceiveKeyExchange( ~sid, ~tid, ~oidI, ~oidR ),
  KETranscriptI( (messageTranscript+<'Key_Exchange_Resp', rsp>) ),
  DHOutputInit( ~sid, ~tid, ~oidI, ~oidR, somepkR,
                respPublicKey^~privKey
  ),
  CommitBeforeFinish( ~sid, ~tid, ~oidI, ~oidR, somepkR ),
  Eq( verify(sign(h(K1_Transcript_Sign), ~ltkR),
             h(K1_Transcript_Sign), somepkR),
      true
  ),
  Eq( K1_Transcript_Sign,
      <version, 'Key_Exchange_Resp_Signing', VCATrancriptI, digest, 
       (messageTranscript+
        <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
         'No_Mutual_auth', respNonce, respPublicKey, 'NULL', 'NULL'>
       )
      >
  ),
  Eq( in_finished_key,
      hkdf(hkdf(hmac(respPublicKey^~privKey, 'salt_o'),
                h(<VCATrancriptI, digest, 
                   (messageTranscript+
                    <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
                     'No_Mutual_auth', respNonce, respPublicKey, 
                     sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
                   )
                  >),
                'resp_hs_data'),
           version, 'finished')
  ),
  Eq( K1_Transcript_HMAC,
      <VCATrancriptI, digest, 
       (messageTranscript+
        <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
         'No_Mutual_auth', respNonce, respPublicKey, 
         sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
       )
      >
  )
  ]->
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATrancriptI,
                    (messageTranscript+
                     <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
                      'No_Mutual_auth', respNonce, respPublicKey, 
                      sign(h(K1_Transcript_Sign), ~ltkR), 
                      hmac(h(K1_Transcript_HMAC), in_finished_key)>
                    ),
                    ~privKey, ~initSessionId, hmac(respPublicKey^~privKey, 'salt_o'),
                    hkdf(hkdf(hmac(respPublicKey^~privKey, 'salt_o'),
                              h(<VCATrancriptI, digest, 
                                 (messageTranscript+
                                  <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                   respSessionId, 'No_Mutual_auth', respNonce, respPublicKey, 
                                   sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
                                 )
                                >),
                              'init_hs_data'),
                         version, 'finished'),
                    hkdf(hkdf(hmac(respPublicKey^~privKey, 'salt_o'),
                              h(<VCATrancriptI, digest, 
                                 (messageTranscript+
                                  <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                   respSessionId, 'No_Mutual_auth', respNonce, respPublicKey, 
                                   sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
                                 )
                                >),
                              'resp_hs_data'),
                         version, 'finished'),
                    sid(~initSessionId, respSessionId), 'AFTER_KE'
   )
   ]

  /*
  rule (modulo AC) I_KE_ProcessAndVerify[color=#43aa8b]:
     [
     KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                      version, VCATrancriptI,
                      (messageTranscript+<'Key_Exchange_Resp', rsp>), ~privKey,
                      ~initSessionId, 'NULL', 'NULL', 'NULL', 'NULL', 'WAIT_KEY_RESP'
     ),
     In( <'Key_Exchange_Resp', version, respSessionId, 
          'No_Mutual_auth', respNonce, respPublicKey, 
          sign(h(K1_Transcript_Sign), ~ltkR), 
          hmac(h(K1_Transcript_HMAC), in_finished_key)>
     )
     ]
    --[
    Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
    SessionId( ~tid, ~sid, sid(~initSessionId, respSessionId) ),
    ReceiveKeyExchange( ~sid, ~tid, ~oidI, ~oidR ),
    KETranscriptI( (messageTranscript+<'Key_Exchange_Resp', rsp>) ),
    DHOutputInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, z ),
    CommitBeforeFinish( ~sid, ~tid, ~oidI, ~oidR, somepkR ),
    Eq( z.1, true ),
    Eq( K1_Transcript_Sign,
        <version, 'Key_Exchange_Resp_Signing', VCATrancriptI, digest, 
         (messageTranscript+
          <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
           'No_Mutual_auth', respNonce, respPublicKey, 'NULL', 'NULL'>
         )
        >
    ),
    Eq( in_finished_key,
        hkdf(hkdf(hmac(z, 'salt_o'),
                  h(<VCATrancriptI, digest, 
                     (messageTranscript+
                      <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
                       'No_Mutual_auth', respNonce, respPublicKey, 
                       sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
                     )
                    >),
                  'resp_hs_data'),
             version, 'finished')
    ),
    Eq( K1_Transcript_HMAC,
        <VCATrancriptI, digest, 
         (messageTranscript+
          <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
           'No_Mutual_auth', respNonce, respPublicKey, 
           sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
         )
        >
    )
    ]->
     [
     KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                      version, VCATrancriptI,
                      (messageTranscript+
                       <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, respSessionId, 
                        'No_Mutual_auth', respNonce, respPublicKey, 
                        sign(h(K1_Transcript_Sign), ~ltkR), 
                        hmac(h(K1_Transcript_HMAC), in_finished_key)>
                      ),
                      ~privKey, ~initSessionId, hmac(z, 'salt_o'),
                      hkdf(hkdf(hmac(z, 'salt_o'),
                                h(<VCATrancriptI, digest, 
                                   (messageTranscript+
                                    <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                     respSessionId, 'No_Mutual_auth', respNonce, respPublicKey, 
                                     sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
                                   )
                                  >),
                                'init_hs_data'),
                           version, 'finished'),
                      hkdf(hkdf(hmac(z, 'salt_o'),
                                h(<VCATrancriptI, digest, 
                                   (messageTranscript+
                                    <'Key_Exchange_Resp', 'Key_Exchange_Resp', version, 
                                     respSessionId, 'No_Mutual_auth', respNonce, respPublicKey, 
                                     sign(h(K1_Transcript_Sign), ~ltkR), 'NULL'>
                                   )
                                  >),
                                'resp_hs_data'),
                           version, 'finished'),
                      sid(~initSessionId, respSessionId), 'AFTER_KE'
     )
     ]
    variants (modulo AC)
     1. ~ltkR = ~ltkR.45
        ~privKey
              = ~privKey.48
        respPublicKey
              = respPublicKey.58
        somepkR
              = pk(~ltkR.45)
        z     = respPublicKey.58^~privKey.48
        z.1   = true
    
     2. ~ltkR = ~ltkR.48
        ~privKey
              = ~privKey.51
        K1_Transcript_Sign
              = K1_Transcript_Sign.55
        respPublicKey
              = respPublicKey.61
        somepkR
              = somepkR.64
        z     = respPublicKey.61^~privKey.51
        z.1   = verify(sign(h(K1_Transcript_Sign.55), ~ltkR.48),
                       h(K1_Transcript_Sign.55), somepkR.64)
    
     3. ~ltkR = ~ltkR.54
        ~privKey
              = ~privKey.57
        K1_Transcript_Sign
              = K1_Transcript_Sign.61
        respPublicKey
              = z.76^inv(~privKey.57)
        somepkR
              = somepkR.70
        z     = z.76
        z.1   = verify(sign(h(K1_Transcript_Sign.61), ~ltkR.54),
                       h(K1_Transcript_Sign.61), somepkR.70)
    
     4. ~ltkR = ~ltkR.54
        ~privKey
              = ~privKey.57
        respPublicKey
              = z.76^inv(~privKey.57)
        somepkR
              = pk(~ltkR.54)
        z     = z.76
        z.1   = true
    
     5. ~ltkR = ~ltkR.303
        ~privKey
              = ~privKey.306
        K1_Transcript_Sign
              = K1_Transcript_Sign.310
        respPublicKey
              = x.602^x.603
        somepkR
              = somepkR.319
        z     = x.602^(~privKey.306*x.603)
        z.1   = verify(sign(h(K1_Transcript_Sign.310), ~ltkR.303),
                       h(K1_Transcript_Sign.310), somepkR.319)
    
     6. ~ltkR = ~ltkR.313
        ~privKey
              = ~privKey.316
        K1_Transcript_Sign
              = K1_Transcript_Sign.320
        respPublicKey
              = x.622^inv((~privKey.316*x.623))
        somepkR
              = somepkR.329
        z     = x.622^inv(x.623)
        z.1   = verify(sign(h(K1_Transcript_Sign.320), ~ltkR.313),
                       h(K1_Transcript_Sign.320), somepkR.329)
    
     7. ~ltkR = ~ltkR.313
        ~privKey
              = ~privKey.316
        K1_Transcript_Sign
              = K1_Transcript_Sign.320
        respPublicKey
              = x.622^(x.623*inv(~privKey.316))
        somepkR
              = somepkR.329
        z     = x.622^x.623
        z.1   = verify(sign(h(K1_Transcript_Sign.320), ~ltkR.313),
                       h(K1_Transcript_Sign.320), somepkR.329)
    
     8. ~ltkR = ~ltkR.314
        ~privKey
              = ~privKey.317
        K1_Transcript_Sign
              = K1_Transcript_Sign.321
        respPublicKey
              = x.623^(x.624*inv((~privKey.317*x.625)))
        somepkR
              = somepkR.330
        z     = x.623^(x.624*inv(x.625))
        z.1   = verify(sign(h(K1_Transcript_Sign.321), ~ltkR.314),
                       h(K1_Transcript_Sign.321), somepkR.330)
    
     9. ~ltkR = ~ltkR.316
        ~privKey
              = ~privKey.319
        respPublicKey
              = x.628^x.629
        somepkR
              = pk(~ltkR.316)
        z     = x.628^(~privKey.319*x.629)
        z.1   = true
    
    10. ~ltkR = ~ltkR.316
        ~privKey
              = ~privKey.319
        respPublicKey
              = x.628^inv((~privKey.319*x.629))
        somepkR
              = pk(~ltkR.316)
        z     = x.628^inv(x.629)
        z.1   = true
    
    11. ~ltkR = ~ltkR.316
        ~privKey
              = ~privKey.319
        respPublicKey
              = x.628^(x.629*inv(~privKey.319))
        somepkR
              = pk(~ltkR.316)
        z     = x.628^x.629
        z.1   = true
    
    12. ~ltkR = ~ltkR.317
        ~privKey
              = ~privKey.320
        respPublicKey
              = x.629^(x.630*inv((~privKey.320*x.631)))
        somepkR
              = pk(~ltkR.317)
        z     = x.629^(x.630*inv(x.631))
        z.1   = true
  */

rule (modulo E) I_Finish_Request[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, (messageTranscript+<'Finish', f>),
                    ~privKey, ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'AFTER_KE'
   )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, bindSid ),
  StartFinishKE( ~sid, ~tid, ~oidI, ~oidR ),
  KETranscriptI( (messageTranscript+<'Finish', f>) )
  ]->
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript,
                    (messageTranscript+
                     <'Finish', 'Finish', version, 
                      hmac(h(<VCATranscript, digest, 
                              (messageTranscript+<'Finish', 'Finish', version, 'NULL'>)>),
                           init_finished_key)
                     >
                    ),
                    ~privKey, ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'PROCESS_FINISH_REQUEST'
   ),
   Out( <'Finish', version, 
         hmac(h(<VCATranscript, digest, 
                 (messageTranscript+<'Finish', 'Finish', version, 'NULL'>)>),
              init_finished_key)
        >
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_Finish_Response[color=#43aa8b]:
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, somedigestI,
                    version, VCATrancript,
                    (messageTranscript+<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>),
                    'NULL', handshake_secret, resp_finished_key, init_finished_key,
                    bindSid, 'AFTER_KE'
   ),
   !Cert( ~oidR, pk(~ltkR), certR ),
   In( <'Finish', version, 
        hmac(h(K2_Transcript_HMAC), in_finished_key)>
   ),
   Fr( ~kuid )
   ]
  --[
  Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
  RespFinish( ~sid, ~tidR, ~oidI, ~oidR ),
  SessionId( ~tidR, ~sid, bindSid ),
  KETranscriptR( (messageTranscript+<'Finish', 'NULL'>+
                  <'Finish_Rsp', 'NULL'>)
  ),
  SesssionMajorSecretResp( ~sid, ~tidR, ~oidI, ~oidR, ~ltkR,
                           handshake_secret
  ),
  Running( ~sid, ~tidR, pk(~ltkR), handshake_secret,
           (messageTranscript+
            <'Finish', 'Finish', version, 
             hmac(h(K2_Transcript_HMAC), in_finished_key)>+
            <'Finish_Rsp', 'Finish_Rsp', version, 
             hmac(h(<VCATrancript, h(certR), 
                     (messageTranscript+
                      <'Finish', 'Finish', version, 
                       hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                      <'Finish_Rsp', version, 'NULL'>)
                    >),
                  resp_finished_key)
            >
           ),
           'Resp'
  ),
  KeyUpdate( ~tidR, ~sid, ~kuid ),
  Eq( init_finished_key, in_finished_key ),
  Eq( <VCATrancript, h(certR), 
       (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
        <'Finish_Rsp', 'NULL'>)
      >,
      K2_Transcript_HMAC
  )
  ]->
   [
   !AppDataKey( ~kuid, ~tidR, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish', 'Finish', version, 
                       hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(<VCATrancript, h(certR), 
                               (messageTranscript+
                                <'Finish', 'Finish', version, 
                                 hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                <'Finish_Rsp', version, 'NULL'>)
                              >),
                            resp_finished_key)
                      >
                     ),
                     'resp_app_data'),
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish', 'Finish', version, 
                       hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(<VCATrancript, h(certR), 
                               (messageTranscript+
                                <'Finish', 'Finish', version, 
                                 hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                <'Finish_Rsp', version, 'NULL'>)
                              >),
                            resp_finished_key)
                      >
                     ),
                     'init_app_data'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish', 'Finish', version, 
                            hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(<VCATrancript, h(certR), 
                                    (messageTranscript+
                                     <'Finish', 'Finish', version, 
                                      hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                     <'Finish_Rsp', version, 'NULL'>)
                                   >),
                                 resp_finished_key)
                           >
                          ),
                          'resp_app_data'),
                     version, 'key'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish', 'Finish', version, 
                            hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(<VCATrancript, h(certR), 
                                    (messageTranscript+
                                     <'Finish', 'Finish', version, 
                                      hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                     <'Finish_Rsp', version, 'NULL'>)
                                   >),
                                 resp_finished_key)
                           >
                          ),
                          'init_app_data'),
                     version, 'key'),
                'Resp'
   ),
   Out( <'Finish_Rsp', version, 
         hmac(h(<VCATrancript, h(certR), 
                 (messageTranscript+
                  <'Finish', 'Finish', version, 
                   hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                  <'Finish_Rsp', version, 'NULL'>)
                >),
              resp_finished_key)
        >
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_Finish_ProcessAndVerify[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, (messageTranscript+<'Finish_Rsp', 'NULL'>),
                    ~privKey, ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'PROCESS_FINISH_REQUEST'
   ),
   !Cert( ~oidI, pk(~ltkI), certI ),
   In( <'Finish_Rsp', version, 
        hmac(h(K1_Transcript_HMAC), in_finished_key)>
   ),
   Fr( ~kuid )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, bindSid ),
  ReceiveFinish( ~sid, ~tid, ~oidI, ~oidR ),
  KETranscriptI( (messageTranscript+<'Finish_Rsp', 'NULL'>) ),
  SesssionMajorSecretInit( ~sid, ~tid, ~oidI, ~oidR, somepkR,
                           handshake_secret
  ),
  Commit( ~sid, ~tid, pk(~ltkI), somepkR, handshake_secret,
          (messageTranscript+
           <'Finish_Rsp', 'Finish_Rsp', version, 
            hmac(h(K1_Transcript_HMAC), in_finished_key)>
          ),
          'Init'
  ),
  KeyUpdate( ~tid, ~sid, ~kuid ),
  Eq( in_finished_key, resp_finished_key ),
  Eq( K1_Transcript_HMAC,
      <VCATranscript, digest, 
       (messageTranscript+<'Finish_Rsp', version, 'NULL'>)>
  )
  ]->
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(K1_Transcript_HMAC), in_finished_key)>
                     ),
                     'init_app_data'),
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(K1_Transcript_HMAC), in_finished_key)>
                     ),
                     'resp_app_data'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(K1_Transcript_HMAC), in_finished_key)>
                          ),
                          'init_app_data'),
                     version, 'key'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(K1_Transcript_HMAC), in_finished_key)>
                          ),
                          'resp_app_data'),
                     version, 'key'),
                'Init'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_DeliverEncap_SendDigest[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, messageTranscript, ~privKey,
                    ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'AFTER_KE'
   ),
   !Cert( ~oidI, pk(~ltkI), certI )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, bindSid ),
  SendEncapsulatedDigest( ~sid, ~tid, ~oidI, ~oidR ),
  KETranscriptI( messageTranscript )
  ]->
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, messageTranscript, ~privKey,
                    ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'SENT_DIGEST'
   ),
   Out( <'Deliver_Encap_Digest', version, h(certI)> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_EncapsResponseAck_RecvDigestGetCertificate[color=#43aa8b]:
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, somedigestI,
                    version, VCATrancript, messageTranscript, 'NULL', handshake_secret,
                    resp_finished_key, init_finished_key, bindSid, 'AFTER_KE'
   ),
   In( <'Deliver_Encap_Digest', version, digest_init> )
   ]
  --[
  Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
  SessionId( ~tidR, ~sid, bindSid ),
  ReceivedEncapsulatedDigest( ~sid, ~tidR, ~oidI, ~oidR ),
  KETranscriptR( messageTranscript )
  ]->
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, digest_init,
                    version, VCATrancript, messageTranscript, 'NULL', handshake_secret,
                    resp_finished_key, init_finished_key, bindSid, 'ACK_DIGEST'
   ),
   Out( <'Encap_Ack_GetCertificate', version> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_DeliverEncap_SendCertificate[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, messageTranscript, ~privKey,
                    ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'SENT_DIGEST'
   ),
   In( <'Encap_Ack_GetCertificate', version> ),
   !Cert( ~oidI, pk(~ltkI), certI )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, bindSid ),
  SendEncapsulatedCertificate( ~sid, ~tid, ~oidI, ~oidR ),
  KETranscriptI( messageTranscript )
  ]->
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, messageTranscript, ~privKey,
                    ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'SENT_CERTIFICATE'
   ),
   Out( <'Deliver_Encap_Certificate', version, certI> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_EncapsResponseAck_RecvCertificate[color=#43aa8b]:
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, digest_init,
                    version, VCATrancript, messageTranscript, 'NULL', handshake_secret,
                    resp_finished_key, init_finished_key, bindSid, 'ACK_DIGEST'
   ),
   !RootCert( ~rootKey ),
   StateResp( ~tidR, ~oidI, ~oidR, version, somealg, <VR, CR, AR>,
              someVCATranscriptR, someoptionsTranscriptR, somepubKI, somedigestI,
              'IDLE'
   ),
   In( <'Deliver_Encap_Digest', version, 
        sign(<~oidI, pk(~ltkI)>, ~rootKey)>
   )
   ]
  --[
  Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
  SessionId( ~tidR, ~sid, bindSid ),
  ReceiveInitCertificate( ~sid, ~tidR, ~oidI, ~oidR ),
  KETranscriptR( messageTranscript ),
  RStoredCert( ~tidR, ~oidI, ~oidR, pk(~ltkI),
               sign(<~oidI, pk(~ltkI)>, ~rootKey)
  ),
  Eq( h(sign(<~oidI, pk(~ltkI)>, ~rootKey)), digest_init )
  ]->
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, pk(~ltkI), digest_init,
                    version, VCATrancript, messageTranscript, 'NULL', handshake_secret,
                    resp_finished_key, init_finished_key, bindSid, 'ACK_CERTIFICATE'
   ),
   StateResp( ~tidR, ~oidI, ~oidR, version, somealg, <VR, CR, AR>,
              someVCATranscriptR, someoptionsTranscriptR, pk(~ltkI), digest_init,
              'IDLE'
   ),
   Out( <'Encap_Ack', version> )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) I_AuthWithOldCert_BeforeFinish[color=#43aa88]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, messageTranscript, ~privKey,
                    ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'AFTER_KE'
   )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, bindSid ),
  KETranscriptI( messageTranscript ),
  IBeforeAuthOldCert( ~sid, ~tid, ~oidI, ~oidR )
  ]->
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript, messageTranscript, ~privKey,
                    ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'SENT_CERTIFICATE'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_AuthWithOldCert_BeforeFinish[color=#43aa88]:
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, digest_init,
                    version, VCATrancript, messageTranscript, 'NULL', handshake_secret,
                    resp_finished_key, init_finished_key, bindSid, 'AFTER_KE'
   )
   ]
  --[
  Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
  SessionId( ~tidR, ~sid, bindSid ),
  KETranscriptR( messageTranscript ),
  RBeforeAuthOldCert( ~sid, ~tidR, ~oidI, ~oidR ),
  Neq( somepkI, 'NULL' ), Neq( digest_init, 'NULL' )
  ]->
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, digest_init,
                    version, VCATrancript, messageTranscript, 'NULL', handshake_secret,
                    resp_finished_key, init_finished_key, bindSid, 'ACK_CERTIFICATE'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_FinishMutualAuth_Request[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript,
                    (messageTranscript+<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>),
                    ~privKey, ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'SENT_CERTIFICATE'
   ),
   !Cert( ~oidI, pk(~ltkI), certI ), In( <'Encap_Ack', version> )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, bindSid ),
  ReceivedACK( ~sid, ~tid, ~oidI, ~oidR ),
  StartFinishKEMutualAuth( ~sid, ~tid, ~oidI, ~oidR ),
  KETranscriptI( (messageTranscript+<'Finish', 'NULL'>+
                  <'Finish_Rsp', 'NULL'>)
  ),
  RunningMutAuth( ~sid, ~tid, pk(~ltkI), somepkR, handshake_secret,
                  (messageTranscript+
                   <'Finish', 'Finish', version, 
                    sign(h(<VCATranscript, digest, 
                            (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                             <'Finish_Rsp', 'NULL'>), 
                            h(certI)>),
                         ~ltkI), 
                    hmac(h(<VCATranscript, digest, 
                            (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                             <'Finish_Rsp', 'NULL'>), 
                            h(certI), 
                            sign(h(<VCATranscript, digest, 
                                    (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                                     <'Finish_Rsp', 'NULL'>), 
                                    h(certI)>),
                                 ~ltkI)
                           >),
                         init_finished_key)
                   >+
                   <'Finish_Rsp', 'NULL'>),
                  'Init'
  )
  ]->
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digest,
                    version, VCATranscript,
                    (messageTranscript+
                     <'Finish', 'Finish', version, 
                      sign(h(<VCATranscript, digest, 
                              (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                               <'Finish_Rsp', 'NULL'>), 
                              h(certI)>),
                           ~ltkI), 
                      hmac(h(<VCATranscript, digest, 
                              (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                               <'Finish_Rsp', 'NULL'>), 
                              h(certI), 
                              sign(h(<VCATranscript, digest, 
                                      (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                                       <'Finish_Rsp', 'NULL'>), 
                                      h(certI)>),
                                   ~ltkI)
                             >),
                           init_finished_key)
                     >+
                     <'Finish_Rsp', 'NULL'>),
                    ~privKey, ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'PROCESS_FINISH_REQUEST_AUTH'
   ),
   Out( <'Finish', version, 
         sign(h(<VCATranscript, digest, 
                 (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                  <'Finish_Rsp', 'NULL'>), 
                 h(certI)>),
              ~ltkI), 
         hmac(h(<VCATranscript, digest, 
                 (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                  <'Finish_Rsp', 'NULL'>), 
                 h(certI), 
                 sign(h(<VCATranscript, digest, 
                         (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
                          <'Finish_Rsp', 'NULL'>), 
                         h(certI)>),
                      ~ltkI)
                >),
              init_finished_key)
        >
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_FinishMutualAuth_Response[color=#43aa8b]:
   [
   KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, digest_init,
                    version, VCATrancript,
                    (messageTranscript+<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>),
                    'NULL', handshake_secret, resp_finished_key, init_finished_key,
                    bindSid, 'ACK_CERTIFICATE'
   ),
   !Cert( ~oidR, pk(~ltkR), certR ),
   In( <'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
        hmac(h(K2_Transcript_HMAC), in_finished_key)>
   ),
   Fr( ~kuid )
   ]
  --[
  Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
  SessionId( ~tidR, ~sid, bindSid ), StartAppData( ~sid, bindSid ),
  RespFinishMutualAuth1( ~sid, ~tidR, ~oidI, ~oidR ),
  KETranscriptR( (messageTranscript+<'Finish', 'NULL'>+
                  <'Finish_Rsp', 'NULL'>)
  ),
  SesssionMajorSecretResp( ~sid, ~tidR, ~oidI, ~oidR, ~ltkR,
                           handshake_secret
  ),
  SesssionMajorSecretRespAuth( ~sid, ~tidR, ~oidI, ~oidR, somepkI,
                               handshake_secret
  ),
  RunningMutAuth( ~sid, ~tidR, pk(~ltkR), somepkI, handshake_secret,
                  (messageTranscript+
                   <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                    hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                   <'Finish_Rsp', 'Finish_Rsp', version, 
                    hmac(h(<VCATrancript, h(certR), 
                            (messageTranscript+
                             <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                              hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                             <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                            digest_init>),
                         resp_finished_key)
                   >
                  ),
                  'Resp'
  ),
  CommitMutAuth( ~sid, ~tidR, pk(~ltkR), somepkI, handshake_secret,
                 (messageTranscript+
                  <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                   hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                  <'Finish_Rsp', 'NULL'>),
                 'Resp'
  ),
  KeyUpdate( ~tidR, ~sid, ~kuid ),
  Eq( verify(sign(h(K2_Transcript_sign), ~ltkI),
             h(K2_Transcript_sign), somepkI),
      true
  ),
  Eq( init_finished_key, in_finished_key ),
  Eq( <VCATrancript, h(certR), 
       (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
        <'Finish_Rsp', 'NULL'>), 
       digest_init, sign(h(K2_Transcript_sign), ~ltkI)>,
      K2_Transcript_HMAC
  ),
  Eq( <VCATrancript, h(certR), 
       (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
        <'Finish_Rsp', 'NULL'>), 
       digest_init>,
      K2_Transcript_sign
  )
  ]->
   [
   !AppDataKey( ~kuid, ~tidR, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                       hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(<VCATrancript, h(certR), 
                               (messageTranscript+
                                <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                                 hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                               digest_init>),
                            resp_finished_key)
                      >
                     ),
                     'resp_app_data'),
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                       hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(<VCATrancript, h(certR), 
                               (messageTranscript+
                                <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                                 hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                               digest_init>),
                            resp_finished_key)
                      >
                     ),
                     'init_app_data'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                            hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(<VCATrancript, h(certR), 
                                    (messageTranscript+
                                     <'Finish', 'Finish', version, 
                                      sign(h(K2_Transcript_sign), ~ltkI), 
                                      hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                     <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                                    digest_init>),
                                 resp_finished_key)
                           >
                          ),
                          'resp_app_data'),
                     version, 'key'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                            hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(<VCATrancript, h(certR), 
                                    (messageTranscript+
                                     <'Finish', 'Finish', version, 
                                      sign(h(K2_Transcript_sign), ~ltkI), 
                                      hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                     <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                                    digest_init>),
                                 resp_finished_key)
                           >
                          ),
                          'init_app_data'),
                     version, 'key'),
                'Resp'
   ),
   Out( <'Finish_Rsp', version, 
         hmac(h(<VCATrancript, h(certR), 
                 (messageTranscript+
                  <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                   hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                  <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                 digest_init>),
              resp_finished_key)
        >
   )
   ]

  /*
  rule (modulo AC) R_FinishMutualAuth_Response[color=#43aa8b]:
     [
     KeyExchangeResp( ~sid, ~tidR, ~oidI, ~oidR, somepkI, digest_init,
                      version, VCATrancript,
                      (messageTranscript+<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>),
                      'NULL', handshake_secret, resp_finished_key, init_finished_key,
                      bindSid, 'ACK_CERTIFICATE'
     ),
     !Cert( ~oidR, pk(~ltkR), certR ),
     In( <'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
          hmac(h(K2_Transcript_HMAC), in_finished_key)>
     ),
     Fr( ~kuid )
     ]
    --[
    Version( ~tidR, version ), CurrentThreadR( ~tidR, ~oidI, ~oidR ),
    SessionId( ~tidR, ~sid, bindSid ), StartAppData( ~sid, bindSid ),
    RespFinishMutualAuth1( ~sid, ~tidR, ~oidI, ~oidR ),
    KETranscriptR( (messageTranscript+<'Finish', 'NULL'>+
                    <'Finish_Rsp', 'NULL'>)
    ),
    SesssionMajorSecretResp( ~sid, ~tidR, ~oidI, ~oidR, ~ltkR,
                             handshake_secret
    ),
    SesssionMajorSecretRespAuth( ~sid, ~tidR, ~oidI, ~oidR, somepkI,
                                 handshake_secret
    ),
    RunningMutAuth( ~sid, ~tidR, pk(~ltkR), somepkI, handshake_secret,
                    (messageTranscript+
                     <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                      hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                     <'Finish_Rsp', 'Finish_Rsp', version, 
                      hmac(h(<VCATrancript, h(certR), 
                              (messageTranscript+
                               <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                                hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                               <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                              digest_init>),
                           resp_finished_key)
                     >
                    ),
                    'Resp'
    ),
    CommitMutAuth( ~sid, ~tidR, pk(~ltkR), somepkI, handshake_secret,
                   (messageTranscript+
                    <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                     hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                    <'Finish_Rsp', 'NULL'>),
                   'Resp'
    ),
    KeyUpdate( ~tidR, ~sid, ~kuid ), Eq( z, true ),
    Eq( init_finished_key, in_finished_key ),
    Eq( <VCATrancript, h(certR), 
         (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
          <'Finish_Rsp', 'NULL'>), 
         digest_init, sign(h(K2_Transcript_sign), ~ltkI)>,
        K2_Transcript_HMAC
    ),
    Eq( <VCATrancript, h(certR), 
         (messageTranscript+<'Finish', 'Finish', version, 'NULL'>+
          <'Finish_Rsp', 'NULL'>), 
         digest_init>,
        K2_Transcript_sign
    )
    ]->
     [
     !AppDataKey( ~kuid, ~tidR, ~sid, ~oidI, ~oidR, bindSid, version,
                  hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                       (messageTranscript+
                        <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                         hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                        <'Finish_Rsp', 'Finish_Rsp', version, 
                         hmac(h(<VCATrancript, h(certR), 
                                 (messageTranscript+
                                  <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                                   hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                  <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                                 digest_init>),
                              resp_finished_key)
                        >
                       ),
                       'resp_app_data'),
                  hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                       (messageTranscript+
                        <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                         hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                        <'Finish_Rsp', 'Finish_Rsp', version, 
                         hmac(h(<VCATrancript, h(certR), 
                                 (messageTranscript+
                                  <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                                   hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                  <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                                 digest_init>),
                              resp_finished_key)
                        >
                       ),
                       'init_app_data'),
                  hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                                 '0_filled'),
                            (messageTranscript+
                             <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                              hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                             <'Finish_Rsp', 'Finish_Rsp', version, 
                              hmac(h(<VCATrancript, h(certR), 
                                      (messageTranscript+
                                       <'Finish', 'Finish', version, 
                                        sign(h(K2_Transcript_sign), ~ltkI), 
                                        hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                       <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                                      digest_init>),
                                   resp_finished_key)
                             >
                            ),
                            'resp_app_data'),
                       version, 'key'),
                  hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                                 '0_filled'),
                            (messageTranscript+
                             <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                              hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                             <'Finish_Rsp', 'Finish_Rsp', version, 
                              hmac(h(<VCATrancript, h(certR), 
                                      (messageTranscript+
                                       <'Finish', 'Finish', version, 
                                        sign(h(K2_Transcript_sign), ~ltkI), 
                                        hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                                       <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                                      digest_init>),
                                   resp_finished_key)
                             >
                            ),
                            'init_app_data'),
                       version, 'key'),
                  'Resp'
     ),
     Out( <'Finish_Rsp', version, 
           hmac(h(<VCATrancript, h(certR), 
                   (messageTranscript+
                    <'Finish', 'Finish', version, sign(h(K2_Transcript_sign), ~ltkI), 
                     hmac(h(K2_Transcript_HMAC), in_finished_key)>+
                    <'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
                   digest_init>),
                resp_finished_key)
          >
     )
     ]
    variants (modulo AC)
    1. ~ltkI = ~ltkI.33
       somepkI
             = pk(~ltkI.33)
       z     = true
    
    2. ~ltkI = ~ltkI.50
       K2_Transcript_sign
             = K2_Transcript_sign.57
       somepkI
             = somepkI.67
       z     = verify(sign(h(K2_Transcript_sign.57), ~ltkI.50),
                      h(K2_Transcript_sign.57), somepkI.67)
  */

rule (modulo E) I_FinishMutualAuth_ProcessAndVerify[color=#43aa8b]:
   [
   KeyExchangeInit( ~sid, ~tid, ~oidI, ~oidR, somepkR, digestR,
                    version, VCATranscript, (messageTranscript+<'Finish_Rsp', 'NULL'>),
                    ~privKey, ~initSessionId, handshake_secret, init_finished_key,
                    resp_finished_key, bindSid, 'PROCESS_FINISH_REQUEST_AUTH'
   ),
   !Cert( ~oidI, pk(~ltkI), certI ),
   In( <'Finish_Rsp', version, 
        hmac(h(K1_Transcript_HMAC), in_finished_key)>
   ),
   Fr( ~kuid )
   ]
  --[
  Version( ~tid, version ), CurrentThreadI( ~tid, ~oidI, ~oidR ),
  SessionId( ~tid, ~sid, bindSid ),
  InitFinishMutualAuth( ~sid, ~tid, ~oidI, ~oidR ),
  SesssionMajorSecretInit( ~sid, ~tid, ~oidI, ~oidR, somepkR,
                           handshake_secret
  ),
  CommitMutAuth( ~sid, ~tid, pk(~ltkI), somepkR, handshake_secret,
                 (messageTranscript+
                  <'Finish_Rsp', 'Finish_Rsp', version, 
                   hmac(h(K1_Transcript_HMAC), in_finished_key)>
                 ),
                 'Init'
  ),
  KeyUpdate( ~tid, ~sid, ~kuid ),
  Eq( in_finished_key, resp_finished_key ),
  Eq( K1_Transcript_HMAC,
      <VCATranscript, digestR, 
       (messageTranscript+<'Finish_Rsp', 'Finish_Rsp', version, 'NULL'>), 
       h(certI)>
  )
  ]->
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(K1_Transcript_HMAC), in_finished_key)>
                     ),
                     'init_app_data'),
                hkdf(hmac(hkdf(handshake_secret, version, 'derived'), '0_filled'),
                     (messageTranscript+
                      <'Finish_Rsp', 'Finish_Rsp', version, 
                       hmac(h(K1_Transcript_HMAC), in_finished_key)>
                     ),
                     'resp_app_data'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(K1_Transcript_HMAC), in_finished_key)>
                          ),
                          'init_app_data'),
                     version, 'key'),
                hkdf(hkdf(hmac(hkdf(handshake_secret, version, 'derived'),
                               '0_filled'),
                          (messageTranscript+
                           <'Finish_Rsp', 'Finish_Rsp', version, 
                            hmac(h(K1_Transcript_HMAC), in_finished_key)>
                          ),
                          'resp_app_data'),
                     version, 'key'),
                'Init'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send_Message[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, encrypt_key, decrypt_key,
                role
   ),
   Fr( ~payload )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  SendMessage( ~sid, ~tid, ~oidI, ~oidR, bindSid,
               senc(~payload, encrypt_key)
  ),
  CurrentKey( ~tid, ~sid, ~kuid ), Version( ~tid, version )
  ]->
   [ Out( senc(~payload, encrypt_key) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receive_Message[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, encrypt_key, decrypt_key,
                role
   ),
   In( senc(payload, decrypt_key) )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  ReceiveMessage( ~sid, ~tid, ~oidI, ~oidR, bindSid,
                  senc(payload, decrypt_key)
  ),
  CurrentKey( ~tid, ~sid, ~kuid ), Version( ~tid, version )
  ]->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_KeyUpdateVerify_RequestInitKey[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, enc_key, dec_key, 'Init'
   ),
   Fr( ~newkuid )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  Version( ~tid, version ), CurrentKey( ~tid, ~sid, ~kuid ),
  KeyUpdate( ~tid, ~sid, ~newkuid ),
  InitKeyUpdate( ~tid, ~sid, ~kuid,
                 hkdf(own_master_secret, version, 'binstr')
  ),
  OnlyOnce( ~tid, ~sid, ~kuid )
  ]->
   [
   !AppDataKey( ~newkuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(own_master_secret, version, 'binstr'), partner_master_secret,
                hkdf(hkdf(own_master_secret, version, 'binstr'), version, 'key'),
                dec_key, 'Init'
   ),
   Out( senc(<'Key_Update', version, 'VerifyNewKey'>,
             hkdf(hkdf(own_master_secret, version, 'binstr'), version, 'key'))
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) R_KeyUpdateVerify_ResponseInitKey[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, enc_key, dec_key, 'Resp'
   ),
   In( senc(<'Key_Update', version, 'VerifyNewKey'>,
            hkdf(hkdf(partner_master_secret, version, 'binstr'), version,
                 'key'))
   ),
   Fr( ~newkuid )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  Version( ~tid, version ), CurrentKey( ~tid, ~sid, ~kuid ),
  KeyUpdate( ~tid, ~sid, ~newkuid ),
  RespKeyUpdate( ~tid, ~sid, ~kuid,
                 hkdf(partner_master_secret, version, 'binstr')
  ),
  RKEyUpdateVerif( ~sid, ~tid, ~kuid )
  ]->
   [
   !AppDataKey( ~newkuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, hkdf(partner_master_secret, version, 'binstr'),
                enc_key,
                hkdf(hkdf(partner_master_secret, version, 'binstr'), version,
                     'key'),
                'Resp'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) I_KeyUpdateVerify_RequestAllKey[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, enc_key, dec_key, 'Init'
   ),
   Fr( ~newkuid )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  Version( ~tid, version ), CurrentKey( ~tid, ~sid, ~kuid ),
  KeyUpdate( ~tid, ~sid, ~newkuid ),
  InitAllKeyUpdate( ~tid, ~sid, ~kuid,
                    hkdf(own_master_secret, version, 'binstr'),
                    hkdf(partner_master_secret, version, 'binstr')
  ),
  OnlyOnce( ~tid, ~sid, ~kuid )
  ]->
   [
   !AppDataKey( ~newkuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(own_master_secret, version, 'binstr'),
                hkdf(partner_master_secret, version, 'binstr'),
                hkdf(hkdf(own_master_secret, version, 'binstr'), version, 'key'),
                hkdf(hkdf(partner_master_secret, version, 'binstr'), version,
                     'key'),
                'Init'
   ),
   Out( senc(<'Key_Update', version, 'VerifyAllKey'>,
             hkdf(hkdf(own_master_secret, version, 'binstr'), version, 'key'))
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) R_KeyUpdateVerify_ResponseAllKey[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, enc_key, dec_key, 'Resp'
   ),
   In( senc(<'Key_Update', version, 'VerifyAllKey'>,
            hkdf(hkdf(partner_master_secret, version, 'binstr'), version,
                 'key'))
   ),
   Fr( ~newkuid )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  Version( ~tid, version ), CurrentKey( ~tid, ~sid, ~kuid ),
  KeyUpdate( ~tid, ~sid, ~newkuid ),
  RespAllKeyUpdate( ~tid, ~sid, ~kuid,
                    hkdf(own_master_secret, version, 'binstr'),
                    hkdf(partner_master_secret, version, 'binstr')
  ),
  RKEyUpdateVerif( ~sid, ~tid, ~kuid )
  ]->
   [
   !AppDataKey( ~newkuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(own_master_secret, version, 'binstr'),
                hkdf(partner_master_secret, version, 'binstr'),
                hkdf(hkdf(own_master_secret, version, 'binstr'), version, 'key'),
                hkdf(hkdf(partner_master_secret, version, 'binstr'), version,
                     'key'),
                'Resp'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) R_KeyUpdateEncap_ResponseRespKey[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, enc_key, dec_key, 'Resp'
   ),
   In( incipher ), Fr( ~newkuid )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  Version( ~tid, version ), CurrentKey( ~tid, ~sid, ~kuid ),
  KeyUpdate( ~tid, ~sid, ~newkuid ),
  RespOwnKeyUpdate( ~tid, ~sid, ~kuid,
                    hkdf(own_master_secret, version, 'binstr')
  ),
  RKEyUpdateVerif( ~sid, ~tid, ~kuid )
  ]->
   [
   !AppDataKey( ~newkuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                hkdf(own_master_secret, version, 'binstr'), partner_master_secret,
                hkdf(hkdf(own_master_secret, version, 'binstr'), version, 'key'),
                dec_key, 'Resp'
   ),
   Out( senc(<'Encap_Key_Update', version, 'VerifyNewKey'>,
             hkdf(hkdf(own_master_secret, version, 'binstr'), version, 'key'))
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) I_KeyUpdateEncapAck_RequestRespKey[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, enc_key, dec_key, 'Init'
   ),
   In( senc(<'Encap_Key_Update', version, 'VerifyNewKey'>,
            new_enc_key)
   ),
   Fr( ~newkuid )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  Version( ~tid, version ), CurrentKey( ~tid, ~sid, ~kuid ),
  KeyUpdate( ~tid, ~sid, ~newkuid ),
  InitPartnerKeyUpdate( ~tid, ~sid, ~kuid,
                        hkdf(partner_master_secret, version, 'binstr')
  ),
  OnlyOnce( ~tid, ~sid, ~kuid )
  ]->
   [
   !AppDataKey( ~newkuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, hkdf(partner_master_secret, version, 'binstr'),
                enc_key,
                hkdf(hkdf(partner_master_secret, version, 'binstr'), version,
                     'key'),
                'Init'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) I_SessionEnd_Request[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, encrypt_key, decrypt_key,
                'Init'
   ),
   Fr( ~payload )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  StartEndSession( ~sid, ~tid, ~oidI, ~oidR ),
  CurrentKey( ~tid, ~sid, ~kuid ), Version( ~tid, version )
  ]->
   [ Out( senc('END_SESSION', encrypt_key) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) R_SessionEndAck_Response[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, encrypt_key, decrypt_key,
                'Resp'
   ),
   In( cipher )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  RespEndSession( ~sid, ~tid, ~oidI, ~oidR ),
  CurrentKey( ~tid, ~sid, ~kuid ), Version( ~tid, version )
  ]->
   [ Out( senc('END_SESSION_ACK', encrypt_key) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) I_SessionEndAck_Process[color=#e9cbff]:
   [
   !AppDataKey( ~kuid, ~tid, ~sid, ~oidI, ~oidR, bindSid, version,
                own_master_secret, partner_master_secret, encrypt_key, decrypt_key,
                'Init'
   ),
   Fr( ~payload )
   ]
  --[
  SessionId( ~tid, ~sid, bindSid ), CurrentSesion( ~tid, ~sid ),
  InitEndSession( ~sid, ~tid, ~oidI, ~oidR ),
  CurrentKey( ~tid, ~sid, ~kuid ), Version( ~tid, version )
  ]->
   [ ]

  /* has exactly the trivial AC variant */

lemma versiontypes [heuristic=S, sources]:
  all-traces
  "∀ tid version #i.
    (Version( tid, version ) @ #i) ⇒
    (∃ #j. (!KU( version ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ tid version #i.
  (Version( tid, version ) @ #i)
 ∧
  ∀ #j. (!KU( version ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma IVCATranscriptType [use_induction, reuse]:
  all-traces
  "∀ trans #i.
    (VCATranscriptI( trans ) @ #i) ⇒
    (∃ gv v gc c ga a.
      trans =
      (<'Algorithms', a>+<'Capabilities', c>+<'Get_Capabilities', gc>+
       <'Get_Version', gv>+<'Negotiate_Algorithms', ga>+<'Version', v>))"
/*
guarded formula characterizing all counter-examples:
"∃ trans #i.
  (VCATranscriptI( trans ) @ #i)
 ∧
  ∀ gv v gc c ga a.
   (trans =
    (<'Algorithms', a>+<'Capabilities', c>+<'Get_Capabilities', gc>+
     <'Get_Version', gv>+<'Negotiate_Algorithms', ga>+<'Version', v>))
  ⇒
   ⊥"
*/
by sorry

lemma RVCATranscriptType [use_induction, reuse, heuristic=S]:
  all-traces
  "∀ trans #i.
    (VCATranscriptR( trans ) @ #i) ⇒
    (∃ gv v gc c ga a.
      trans =
      (<'Algorithms', a>+<'Capabilities', c>+<'Get_Capabilities', gc>+
       <'Get_Version', gv>+<'Negotiate_Algorithms', ga>+<'Version', v>))"
/*
guarded formula characterizing all counter-examples:
"∃ trans #i.
  (VCATranscriptR( trans ) @ #i)
 ∧
  ∀ gv v gc c ga a.
   (trans =
    (<'Algorithms', a>+<'Capabilities', c>+<'Get_Capabilities', gc>+
     <'Get_Version', gv>+<'Negotiate_Algorithms', ga>+<'Version', v>))
  ⇒
   ⊥"
*/
by sorry

lemma IKETranscriptType [use_induction, reuse]:
  all-traces
  "∀ trans #i.
    (KETranscriptI( trans ) @ #i) ⇒
    (∃ gke ker f fr.
      trans =
      (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
       <'Key_Exchange_Resp', ker>))"
/*
guarded formula characterizing all counter-examples:
"∃ trans #i.
  (KETranscriptI( trans ) @ #i)
 ∧
  ∀ gke ker f fr.
   (trans =
    (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
     <'Key_Exchange_Resp', ker>))
  ⇒
   ⊥"
*/
by sorry

lemma RKETranscriptType [use_induction, reuse, heuristic=S]:
  all-traces
  "∀ trans #i.
    (KETranscriptR( trans ) @ #i) ⇒
    (∃ gke ker f fr.
      trans =
      (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
       <'Key_Exchange_Resp', ker>))"
/*
guarded formula characterizing all counter-examples:
"∃ trans #i.
  (KETranscriptR( trans ) @ #i)
 ∧
  ∀ gke ker f fr.
   (trans =
    (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
     <'Key_Exchange_Resp', ker>))
  ⇒
   ⊥"
*/
by sorry

lemma UniqueThreadsInit [reuse, heuristic=S, use_induction]:
  all-traces
  "∀ tid oidI oidR oidI2 oidR2 #i #j.
    ((CurrentThreadI( tid, oidI, oidR ) @ #i) ∧
     (CurrentThreadI( tid, oidI2, oidR2 ) @ #j)) ⇒
    ((oidI = oidI2) ∧ (oidR = oidR2))"
/*
guarded formula characterizing all counter-examples:
"∃ tid oidI oidR oidI2 oidR2 #i #j.
  (CurrentThreadI( tid, oidI, oidR ) @ #i) ∧
  (CurrentThreadI( tid, oidI2, oidR2 ) @ #j)
 ∧
  ((¬(oidI = oidI2)) ∨ (¬(oidR = oidR2)))"
*/
by sorry

lemma UniqueThreadsResp [reuse, heuristic=S, use_induction]:
  all-traces
  "∀ tid oidI oidI2 oidR oidR2 #i #j.
    ((CurrentThreadR( tid, oidI, oidR ) @ #i) ∧
     (CurrentThreadR( tid, oidI2, oidR2 ) @ #j)) ⇒
    ((oidR = oidR2) ∧ (oidI = oidI2))"
/*
guarded formula characterizing all counter-examples:
"∃ tid oidI oidI2 oidR oidR2 #i #j.
  (CurrentThreadR( tid, oidI, oidR ) @ #i) ∧
  (CurrentThreadR( tid, oidI2, oidR2 ) @ #j)
 ∧
  ((¬(oidR = oidR2)) ∨ (¬(oidI = oidI2)))"
*/
by sorry

lemma SecretLtk [reuse, use_induction]:
  all-traces
  "∀ oid ltk somepk #i.
    (Honest( oid, ltk, somepk ) @ #i) ⇒ (¬(∃ #j. K( ltk ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ oid ltk somepk #i.
  (Honest( oid, ltk, somepk ) @ #i) ∧ ∃ #j. (K( ltk ) @ #j)"
*/
by sorry

lemma SecretRootkey [reuse, use_induction]:
  all-traces
  "∀ ltk #i. (CreateRootCert( ltk ) @ #i) ⇒ (¬(∃ #j. K( ltk ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk #i. (CreateRootCert( ltk ) @ #i) ∧ ∃ #j. (K( ltk ) @ #j)"
*/
by sorry

lemma SingleRespHandshakePerSessionId [reuse, use_induction]:
  all-traces
  "∀ sid tidR1 tidR2 oidI1 oidI2 oidR1 oidR2 ltkR1 ltkR2 secret1
     secret2 #i #j.
    ((SesssionMajorSecretResp( sid, tidR1, oidI1, oidR1, ltkR1, secret1
      ) @ #i) ∧
     (SesssionMajorSecretResp( sid, tidR2, oidI2, oidR2, ltkR2, secret2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ sid tidR1 tidR2 oidI1 oidI2 oidR1 oidR2 ltkR1 ltkR2 secret1
   secret2 #i #j.
  (SesssionMajorSecretResp( sid, tidR1, oidI1, oidR1, ltkR1, secret1
   ) @ #i) ∧
  (SesssionMajorSecretResp( sid, tidR2, oidI2, oidR2, ltkR2, secret2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma SingleInitHandshakePerSessionId [reuse, use_induction]:
  all-traces
  "∀ sid tid1 tid2 oidI1 oidI2 oidR1 oidR2 somepkR1 somepkR2 secret1
     secret2 #i #j.
    ((SesssionMajorSecretInit( sid, tid1, oidI1, oidR1, somepkR1,
                               secret1
      ) @ #i) ∧
     (SesssionMajorSecretInit( sid, tid2, oidI2, oidR2, somepkR2,
                               secret2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ sid tid1 tid2 oidI1 oidI2 oidR1 oidR2 somepkR1 somepkR2 secret1
   secret2 #i #j.
  (SesssionMajorSecretInit( sid, tid1, oidI1, oidR1, somepkR1,
                            secret1
   ) @ #i) ∧
  (SesssionMajorSecretInit( sid, tid2, oidI2, oidR2, somepkR2,
                            secret2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma ICertOrigin [reuse, use_induction]:
  all-traces
  "∀ tidR oidI oidR pkI certI #i.
    (RStoredCert( tidR, oidI, oidR, pkI, certI ) @ #i) ⇒
    (((∃ someoidI ltk #j.
        (#j < #i) ∧ (Honest( someoidI, ltk, pkI ) @ #j)) ∨
      (∃ someoidI ltk #j.
        (#j < #i) ∧ (Attacker( someoidI, ltk, pkI ) @ #j))) ∨
     (¬(∃ ltk #j. (K( ltk )[-] @ #j) ∧ (pkI = pk(ltk)))))"
/*
guarded formula characterizing all counter-examples:
"∃ tidR oidI oidR pkI certI #i.
  (RStoredCert( tidR, oidI, oidR, pkI, certI ) @ #i)
 ∧
  (∀ someoidI ltk #j.
    (Honest( someoidI, ltk, pkI ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ someoidI ltk #j.
    (Attacker( someoidI, ltk, pkI ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∃ ltk #j. (K( ltk )[-] @ #j) ∧ (pkI = pk(ltk)))"
*/
by sorry

lemma RCertOrigin [reuse, use_induction]:
  all-traces
  "∀ tid oidI oidR pkR certR #i.
    (IStoredCert( tid, oidI, oidR, pkR, certR ) @ #i) ⇒
    (((∃ ltk #j. (#j < #i) ∧ (Honest( oidR, ltk, pkR ) @ #j)) ∨
      (∃ ltk #j. (#j < #i) ∧ (Attacker( oidR, ltk, pkR ) @ #j))) ∨
     (¬(∃ ltk #j. (K( ltk ) @ #j) ∧ (pkR = pk(ltk)))))"
/*
guarded formula characterizing all counter-examples:
"∃ tid oidI oidR pkR certR #i.
  (IStoredCert( tid, oidI, oidR, pkR, certR ) @ #i)
 ∧
  (∀ ltk #j. (Honest( oidR, ltk, pkR ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ ltk #j. (Attacker( oidR, ltk, pkR ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∃ ltk #j. (K( ltk ) @ #j) ∧ (pkR = pk(ltk)))"
*/
by sorry

lemma can_reach_VCA_init [heuristic=S]:
  exists-trace
  "∃ tid oidI oidR #i. InitReachVCA( tid, oidI, oidR ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ tid oidI oidR #i. (InitReachVCA( tid, oidI, oidR ) @ #i)"
*/
by sorry

lemma can_reach_VCA_resp [heuristic=S]:
  exists-trace
  "∃ tid oidI oidR #i. RespReachVCA( tid, oidI, oidR ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ tid oidI oidR #i. (RespReachVCA( tid, oidI, oidR ) @ #i)"
*/
by sorry

lemma can_reach_ke_req_init [heuristic=S,
                             hide_lemma=RespOptionLoopBreaker]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2.
    (((InitReachVCA( tid, oid, oidR ) @ #i) ∧
      (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
     (#i < #i2)) ∧
    (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
      ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
       (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)
 ∧
  (#i < #i2) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_reach_ke_rec_init [heuristic=S,
                             hide_lemma=RespOptionLoopBreaker, hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2 #i3.
    (((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
            (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
           (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
          (#i < #i2)) ∧
         (#i2 < #i3)) ∧
        (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
          ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
           (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
         ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
          (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
        ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
       ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
      ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
       (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2 #i3.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y)"
*/
simplify
solve( StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
                  (<'Algorithms', 'NULL'>+<'Capabilities', c>+
                   <'Get_Capabilities', gc>+<'Get_Version', gv>+
                   <'Negotiate_Algorithms', ga>+<'Version', v>),
                  optionsTranscript, 'NULL', 'NULL', 'START_GETALGORITHMS'
       ) ▶₀ #i )
  case I_Algorithms_Request
  solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pkR, digestR,
                          version, VCATrancriptI,
                          (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                           <'Key_Exchange_Resp', ker>),
                          'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
         ) ▶₀ #i2 )
    case I_Spawn_new_PK_Session
    solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pk(~ltkR), digest,
                            version.1, VCATrancriptI.1,
                            (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                             <'Key_Exchange_Resp', rsp>),
                            ~privKey, ~initSessionId.1, 'NULL', 'NULL', 'NULL', 'NULL',
                            'WAIT_KEY_RESP'
           ) ▶₀ #i3 )
      case I_KE_Request
      solve( StateInit( ~tid, ~oid, ~oidR, version, axI, <VI, CI, AI>,
                        VCATrancriptI, optionsTranscriptI, somePKR, digestR, 'IDLE'
             ) ▶₀ #vr.5 )
        case I_Algorithms_ProcessResponse
        solve( !KU( sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                            (<'Algorithms', 'Algorithms', vx, ax>+
                             <'Capabilities', 'Capabilities', vx, CR>+
                             <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                             <'Get_Version', 'Get_Version', '1'>+
                             <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                             <'Version', 'Version', VR>), 
                            h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                            (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                             <'Get_Key_Exchange', 'Get_Key_Exchange', vx, ~initSessionId, 
                              ~nonce, 'g'^~newPrivKey>+
                             <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, respSessionId, 
                              'No_Mutual_auth', respNonce, respPublicKey, 'NULL', 'NULL'>
                            )
                           >),
                         ~ltkR)
               ) @ #vk.18 )
          case R_KE_Response
          solve( StateResp( ~tidR, ~oidI, ~oidR, vx, axR, <VR.1, CR.2, AR>,
                            (<'Algorithms', 'Algorithms', vx, ax>+
                             <'Capabilities', 'Capabilities', vx, CR>+
                             <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                             <'Get_Version', 'Get_Version', '1'>+
                             <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                             <'Version', 'Version', VR>),
                            optionsTranscriptR, somepkI, somedigestI, 'IDLE'
                 ) ▶₀ #vr.15 )
            case R_Algorithms_Response
            solve( !KU( ~initSessionId ) @ #vk.46 )
              case I_KE_Request
              solve( !KU( ~nonce ) @ #vk.50 )
                case I_KE_Request
                solve( !KU( ~respSessionId ) @ #vk.24 )
                  case R_KE_Response
                  solve( !KU( ~respNonce ) @ #vk.27 )
                    case R_KE_Response
                    solve( !KU( sign(<~oidR, pk(~ltkR)>, ~rootkey) ) @ #vk.49 )
                      case A_getCertHonest
                      solve( !KU( hmac(h(<
                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                           <'Capabilities', 'Capabilities', vx, CR>+
                                           <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                           <'Get_Version', 'Get_Version', '1'>+
                                           <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, 
                                            a2>+
                                           <'Version', 'Version', v1.1, v2.1>), 
                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                          (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                           <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                            ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                           <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                            ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                            'g'^~respPrivKey, 
                                            sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                    (<'Algorithms', 'Algorithms', vx, ax>+
                                                     <'Capabilities', 'Capabilities', vx, CR>+
                                                     <'Get_Capabilities', 'Get_Capabilities', vx, C
                                                     >+
                                                     <'Get_Version', 'Get_Version', '1'>+
                                                     <'Negotiate_Algorithms', 
                                                      'Negotiate_Algorithms', vx, a1, a2>+
                                                     <'Version', 'Version', v1.1, v2.1>), 
                                                    h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                    (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                     <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                      ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                     <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                      ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                      'g'^~respPrivKey, 'NULL', 'NULL'>
                                                    )
                                                   >),
                                                 ~ltkR), 
                                            'NULL'>
                                          )
                                         >),
                                       hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey), 'salt_o'),
                                                 h(<
                                                    (<'Algorithms', 'Algorithms', vx, ax>+
                                                     <'Capabilities', 'Capabilities', vx, CR>+
                                                     <'Get_Capabilities', 'Get_Capabilities', vx, C
                                                     >+
                                                     <'Get_Version', 'Get_Version', '1'>+
                                                     <'Negotiate_Algorithms', 
                                                      'Negotiate_Algorithms', vx, a1, a2>+
                                                     <'Version', 'Version', v1.1, v2.1>), 
                                                    h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                    (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                     <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                      ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                     <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                      ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                      'g'^~respPrivKey, 
                                                      sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                              (<'Algorithms', 'Algorithms', vx, ax>+
                                                               <'Capabilities', 'Capabilities', vx, 
                                                                CR>+
                                                               <'Get_Capabilities', 
                                                                'Get_Capabilities', vx, C>+
                                                               <'Get_Version', 'Get_Version', '1'>+
                                                               <'Negotiate_Algorithms', 
                                                                'Negotiate_Algorithms', vx, a1, a2>+
                                                               <'Version', 'Version', v1.1, v2.1>), 
                                                              h(sign(<~oidR, pk(~ltkR)>,
                                                                     ~rootkey)), 
                                                              (<'Finish', 'NULL'>+
                                                               <'Finish_Rsp', 'NULL'>+
                                                               <'Get_Key_Exchange', 
                                                                'Get_Key_Exchange', vx, 
                                                                ~initSessionId, ~nonce, 
                                                                'g'^~newPrivKey>+
                                                               <'Key_Exchange_Resp', 
                                                                'Key_Exchange_Resp', vx, 
                                                                ~respSessionId, 'No_Mutual_auth', 
                                                                ~respNonce, 'g'^~respPrivKey, 
                                                                'NULL', 'NULL'>
                                                              )
                                                             >),
                                                           ~ltkR), 
                                                      'NULL'>
                                                    )
                                                   >),
                                                 'resp_hs_data'),
                                            vx, 'finished'))
                             ) @ #vk.30 )
                        case R_KE_Response
                        solve( !KU( pk(~ltkR) ) @ #vk.49 )
                          case A_getCertHonest
                          solve( !KU( 'g'^~newPrivKey ) @ #vk.51 )
                            case I_KE_Request
                            solve( !KU( 'g'^~respPrivKey ) @ #vk.33 )
                              case R_KE_Response
                              SOLVED // trace found
                            qed
                          next
                            case c_exp
                            by sorry
                          qed
                        next
                          case c_pk
                          by sorry
                        qed
                      next
                        case c_hmac
                        by sorry
                      qed
                    next
                      case I_DeliverEncap_SendCertificate
                      by contradiction /* cyclic */
                    next
                      case c_sign
                      by sorry
                    qed
                  qed
                qed
              qed
            qed
          next
            case R_EncapsResponseAck_RecvCertificate
            by contradiction /* cyclic */
          next
            case R_Spawn_new_PK_Session
            by contradiction /* cyclic */
          qed
        next
          case c_sign
          by sorry
        qed
      next
        case I_Spawn_new_PK_Session
        by contradiction /* cyclic */
      qed
    qed
  qed
qed

lemma can_reach_ke_resp [heuristic=S,
                         hide_lemma=RespOptionLoopBreaker]:
  exists-trace
  "∃ sid tid oidI oidR s2 #i #i2.
    (((RespReachVCA( tid, oidI, oidR ) @ #i) ∧
      (SendKEResponse( sid, tid, oidI, oidR, s2 ) @ #i2)) ∧
     (#i < #i2)) ∧
    (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
      ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
       (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oidI oidR s2 #i #i2.
  (RespReachVCA( tid, oidI, oidR ) @ #i) ∧
  (SendKEResponse( sid, tid, oidI, oidR, s2 ) @ #i2)
 ∧
  (#i < #i2) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_reach_fin_req_init [heuristic=S, hide_lemma=ICertOrigin,
                              hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2 #i3 #i4.
    (((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
              (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
             (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
            (StartFinishKE( sid, tid, oid, oidR ) @ #i4)) ∧
           (#i < #i2)) ∧
          (#i2 < #i3)) ∧
         (#i3 < #i4)) ∧
        (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
          ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
           (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
         ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
        ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
       ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
        (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
      ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
       (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2 #i3 #i4.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (StartFinishKE( sid, tid, oid, oidR ) @ #i4)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#i3 < #i4) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_reach_fin_rec_init [heuristic=S, hide_lemma=ICertOrigin,
                              hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2 #i3 #i4 #i5.
    (((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                    (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                   (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                  (StartFinishKE( sid, tid, oid, oidR ) @ #i4)) ∧
                 (ReceiveFinish( sid, tid, oid, oidR ) @ #i5)) ∧
                (#i < #i2)) ∧
               (#i2 < #i3)) ∧
              (#i3 < #i4)) ∧
             (#i4 < #i5)) ∧
            (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
           (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
             ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
              (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
            ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
             (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
           ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
          ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
           (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
         ((StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (StartFinishKE( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
        ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
       ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
      ((ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (ReceiveFinish( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2 #i3 #i4 #i5.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (StartFinishKE( sid, tid, oid, oidR ) @ #i4) ∧
  (ReceiveFinish( sid, tid, oid, oidR ) @ #i5)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#i3 < #i4) ∧
  (#i4 < #i5) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveFinish( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
simplify
solve( StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
                  (<'Algorithms', 'NULL'>+<'Capabilities', c>+
                   <'Get_Capabilities', gc>+<'Get_Version', gv>+
                   <'Negotiate_Algorithms', ga>+<'Version', v>),
                  optionsTranscript, 'NULL', 'NULL', 'START_GETALGORITHMS'
       ) ▶₀ #i )
  case I_Algorithms_Request
  solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pkR, digestR,
                          version, VCATrancriptI,
                          (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                           <'Key_Exchange_Resp', ker>),
                          'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
         ) ▶₀ #i2 )
    case I_Spawn_new_PK_Session
    solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pk(~ltkR), digest,
                            version.1, VCATrancriptI.1,
                            (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                             <'Key_Exchange_Resp', rsp>),
                            ~privKey, ~initSessionId.1, 'NULL', 'NULL', 'NULL', 'NULL',
                            'WAIT_KEY_RESP'
           ) ▶₀ #i3 )
      case I_KE_Request
      solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, somepkR, digest,
                              version.1, VCATranscript,
                              (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                               <'Key_Exchange_Resp', ker>),
                              ~privKey, ~initSessionId.1, handshake_secret, init_finished_key,
                              resp_finished_key, bindSid, 'AFTER_KE'
             ) ▶₀ #i4 )
        case I_KE_ProcessAndVerify
        solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, somepkR, digest,
                                version.1, VCATranscript,
                                (<'Finish', f>+<'Finish_Rsp', 'NULL'>+<'Get_Key_Exchange', gke>+
                                 <'Key_Exchange_Resp', ker>),
                                ~privKey, ~initSessionId.1, handshake_secret, init_finished_key,
                                in_finished_key, bindSid, 'PROCESS_FINISH_REQUEST'
               ) ▶₀ #i5 )
          case I_Finish_Request
          solve( !Cert( ~oid, pk(~ltkI), certI ) ▶₁ #i5 )
            case A_getCertHonest
            solve( StateInit( ~tid, ~oid, ~oidR, version, axI, <VI, CI, AI>,
                              VCATrancriptI, optionsTranscriptI, somePKR, digestR, 'IDLE'
                   ) ▶₀ #vr.5 )
              case I_Algorithms_ProcessResponse
              solve( !KU( sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                  (<'Algorithms', 'Algorithms', vx, ax>+
                                   <'Capabilities', 'Capabilities', vx, CR>+
                                   <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                   <'Get_Version', 'Get_Version', '1'>+
                                   <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                   <'Version', 'Version', VR>), 
                                  h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                  (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                   <'Get_Key_Exchange', 'Get_Key_Exchange', vx, ~initSessionId, 
                                    ~nonce, 'g'^~newPrivKey>+
                                   <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, respSessionId, 
                                    'No_Mutual_auth', respNonce, respPublicKey, 'NULL', 'NULL'>
                                  )
                                 >),
                               ~ltkR)
                     ) @ #vk.20 )
                case R_KE_Response
                solve( StateResp( ~tidR, ~oidI, ~oidR, vx, axR, <VR.1, CR.2, AR>,
                                  (<'Algorithms', 'Algorithms', vx, ax>+
                                   <'Capabilities', 'Capabilities', vx, CR>+
                                   <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                   <'Get_Version', 'Get_Version', '1'>+
                                   <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                   <'Version', 'Version', VR>),
                                  optionsTranscriptR, somepkI, somedigestI, 'IDLE'
                       ) ▶₀ #vr.16 )
                  case R_Algorithms_Response
                  solve( !KU( hmac(h(<
                                      (<'Algorithms', 'Algorithms', vx, ax>+
                                       <'Capabilities', 'Capabilities', vx, CR>+
                                       <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                       <'Get_Version', 'Get_Version', '1'>+
                                       <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                       <'Version', 'Version', v1.1, v2.1>), 
                                      h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                      (
                                       <'Finish', 'Finish', vx, 
                                        hmac(h(<
                                                (<'Algorithms', 'Algorithms', vx, ax>+
                                                 <'Capabilities', 'Capabilities', vx, CR>+
                                                 <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                                 <'Get_Version', 'Get_Version', '1'>+
                                                 <'Negotiate_Algorithms', 'Negotiate_Algorithms', 
                                                  vx, a1, a2>+
                                                 <'Version', 'Version', v1.1, v2.1>), 
                                                h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                (<'Finish', 'Finish', vx, 'NULL'>+
                                                 <'Finish_Rsp', 'NULL'>+
                                                 <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                  ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                 <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                  ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                  'g'^~respPrivKey, 
                                                  sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                                           <'Capabilities', 'Capabilities', vx, CR>+
                                                           <'Get_Capabilities', 'Get_Capabilities', 
                                                            vx, C>+
                                                           <'Get_Version', 'Get_Version', '1'>+
                                                           <'Negotiate_Algorithms', 
                                                            'Negotiate_Algorithms', vx, a1, a2>+
                                                           <'Version', 'Version', v1.1, v2.1>), 
                                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                          (<'Finish', 'NULL'>+
                                                           <'Finish_Rsp', 'NULL'>+
                                                           <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                            vx, ~initSessionId, ~nonce, 
                                                            'g'^~newPrivKey>+
                                                           <'Key_Exchange_Resp', 
                                                            'Key_Exchange_Resp', vx, 
                                                            ~respSessionId, 'No_Mutual_auth', 
                                                            ~respNonce, 'g'^~respPrivKey, 'NULL', 
                                                            'NULL'>
                                                          )
                                                         >),
                                                       ~ltkR), 
                                                  hmac(h(<
                                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                                           <'Capabilities', 'Capabilities', vx, CR>+
                                                           <'Get_Capabilities', 'Get_Capabilities', 
                                                            vx, C>+
                                                           <'Get_Version', 'Get_Version', '1'>+
                                                           <'Negotiate_Algorithms', 
                                                            'Negotiate_Algorithms', vx, a1, a2>+
                                                           <'Version', 'Version', v1.1, v2.1>), 
                                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                          (<'Finish', 'NULL'>+
                                                           <'Finish_Rsp', 'NULL'>+
                                                           <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                            vx, ~initSessionId, ~nonce, 
                                                            'g'^~newPrivKey>+
                                                           <'Key_Exchange_Resp', 
                                                            'Key_Exchange_Resp', vx, 
                                                            ~respSessionId, 'No_Mutual_auth', 
                                                            ~respNonce, 'g'^~respPrivKey, 
                                                            sign(h(<vx, 
                                                                    'Key_Exchange_Resp_Signing', 
                                                                    (
                                                                     <'Algorithms', 'Algorithms', 
                                                                      vx, ax>+
                                                                     <'Capabilities', 
                                                                      'Capabilities', vx, CR>+
                                                                     <'Get_Capabilities', 
                                                                      'Get_Capabilities', vx, C>+
                                                                     <'Get_Version', 'Get_Version', 
                                                                      '1'>+
                                                                     <'Negotiate_Algorithms', 
                                                                      'Negotiate_Algorithms', vx, 
                                                                      a1, a2>+
                                                                     <'Version', 'Version', v1.1, 
                                                                      v2.1>
                                                                    ), 
                                                                    h(sign(<~oidR, pk(~ltkR)>,
                                                                           ~rootkey)), 
                                                                    (<'Finish', 'NULL'>+
                                                                     <'Finish_Rsp', 'NULL'>+
                                                                     <'Get_Key_Exchange', 
                                                                      'Get_Key_Exchange', vx, 
                                                                      ~initSessionId, ~nonce, 
                                                                      'g'^~newPrivKey>+
                                                                     <'Key_Exchange_Resp', 
                                                                      'Key_Exchange_Resp', vx, 
                                                                      ~respSessionId, 
                                                                      'No_Mutual_auth', ~respNonce, 
                                                                      'g'^~respPrivKey, 'NULL', 
                                                                      'NULL'>
                                                                    )
                                                                   >),
                                                                 ~ltkR), 
                                                            'NULL'>
                                                          )
                                                         >),
                                                       hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey
                                                                          ),
                                                                      'salt_o'),
                                                                 h(<
                                                                    (
                                                                     <'Algorithms', 'Algorithms', 
                                                                      vx, ax>+
                                                                     <'Capabilities', 
                                                                      'Capabilities', vx, CR>+
                                                                     <'Get_Capabilities', 
                                                                      'Get_Capabilities', vx, C>+
                                                                     <'Get_Version', 'Get_Version', 
                                                                      '1'>+
                                                                     <'Negotiate_Algorithms', 
                                                                      'Negotiate_Algorithms', vx, 
                                                                      a1, a2>+
                                                                     <'Version', 'Version', v1.1, 
                                                                      v2.1>
                                                                    ), 
                                                                    h(sign(<~oidR, pk(~ltkR)>,
                                                                           ~rootkey)), 
                                                                    (<'Finish', 'NULL'>+
                                                                     <'Finish_Rsp', 'NULL'>+
                                                                     <'Get_Key_Exchange', 
                                                                      'Get_Key_Exchange', vx, 
                                                                      ~initSessionId, ~nonce, 
                                                                      'g'^~newPrivKey>+
                                                                     <'Key_Exchange_Resp', 
                                                                      'Key_Exchange_Resp', vx, 
                                                                      ~respSessionId, 
                                                                      'No_Mutual_auth', ~respNonce, 
                                                                      'g'^~respPrivKey, 
                                                                      sign(h(<vx, 
                                                                              'Key_Exchange_Resp_Signing', 
                                                                              (
                                                                               <'Algorithms', 
                                                                                'Algorithms', vx, ax
                                                                               >+
                                                                               <'Capabilities', 
                                                                                'Capabilities', vx, 
                                                                                CR>+
                                                                               <'Get_Capabilities', 
                                                                                'Get_Capabilities', 
                                                                                vx, C>+
                                                                               <'Get_Version', 
                                                                                'Get_Version', '1'>+
                                                                               <
                                                                                'Negotiate_Algorithms', 
                                                                                'Negotiate_Algorithms', 
                                                                                vx, a1, a2>+
                                                                               <'Version', 
                                                                                'Version', v1.1, 
                                                                                v2.1>
                                                                              ), 
                                                                              h(sign(<~oidR, 
                                                                                      pk(~ltkR)>,
                                                                                     ~rootkey)), 
                                                                              (<'Finish', 'NULL'>+
                                                                               <'Finish_Rsp', 'NULL'
                                                                               >+
                                                                               <'Get_Key_Exchange', 
                                                                                'Get_Key_Exchange', 
                                                                                vx, ~initSessionId, 
                                                                                ~nonce, 
                                                                                'g'^~newPrivKey>+
                                                                               <
                                                                                'Key_Exchange_Resp', 
                                                                                'Key_Exchange_Resp', 
                                                                                vx, ~respSessionId, 
                                                                                'No_Mutual_auth', 
                                                                                ~respNonce, 
                                                                                'g'^~respPrivKey, 
                                                                                'NULL', 'NULL'>
                                                                              )
                                                                             >),
                                                                           ~ltkR), 
                                                                      'NULL'>
                                                                    )
                                                                   >),
                                                                 'resp_hs_data'),
                                                            vx, 'finished'))
                                                 >
                                                )
                                               >),
                                             hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey),
                                                            'salt_o'),
                                                       h(<
                                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                                           <'Capabilities', 'Capabilities', vx, CR>+
                                                           <'Get_Capabilities', 'Get_Capabilities', 
                                                            vx, C>+
                                                           <'Get_Version', 'Get_Version', '1'>+
                                                           <'Negotiate_Algorithms', 
                                                            'Negotiate_Algorithms', vx, a1, a2>+
                                                           <'Version', 'Version', v1.1, v2.1>), 
                                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                          (<'Finish', 'NULL'>+
                                                           <'Finish_Rsp', 'NULL'>+
                                                           <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                            vx, ~initSessionId, ~nonce, 
                                                            'g'^~newPrivKey>+
                                                           <'Key_Exchange_Resp', 
                                                            'Key_Exchange_Resp', vx, 
                                                            ~respSessionId, 'No_Mutual_auth', 
                                                            ~respNonce, 'g'^~respPrivKey, 
                                                            sign(h(<vx, 
                                                                    'Key_Exchange_Resp_Signing', 
                                                                    (
                                                                     <'Algorithms', 'Algorithms', 
                                                                      vx, ax>+
                                                                     <'Capabilities', 
                                                                      'Capabilities', vx, CR>+
                                                                     <'Get_Capabilities', 
                                                                      'Get_Capabilities', vx, C>+
                                                                     <'Get_Version', 'Get_Version', 
                                                                      '1'>+
                                                                     <'Negotiate_Algorithms', 
                                                                      'Negotiate_Algorithms', vx, 
                                                                      a1, a2>+
                                                                     <'Version', 'Version', v1.1, 
                                                                      v2.1>
                                                                    ), 
                                                                    h(sign(<~oidR, pk(~ltkR)>,
                                                                           ~rootkey)), 
                                                                    (<'Finish', 'NULL'>+
                                                                     <'Finish_Rsp', 'NULL'>+
                                                                     <'Get_Key_Exchange', 
                                                                      'Get_Key_Exchange', vx, 
                                                                      ~initSessionId, ~nonce, 
                                                                      'g'^~newPrivKey>+
                                                                     <'Key_Exchange_Resp', 
                                                                      'Key_Exchange_Resp', vx, 
                                                                      ~respSessionId, 
                                                                      'No_Mutual_auth', ~respNonce, 
                                                                      'g'^~respPrivKey, 'NULL', 
                                                                      'NULL'>
                                                                    )
                                                                   >),
                                                                 ~ltkR), 
                                                            'NULL'>
                                                          )
                                                         >),
                                                       'init_hs_data'),
                                                  vx, 'finished'))
                                       >+
                                       <'Finish_Rsp', vx, 'NULL'>+
                                       <'Get_Key_Exchange', 'Get_Key_Exchange', vx, ~initSessionId, 
                                        ~nonce, 'g'^~newPrivKey>+
                                       <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                        ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                        'g'^~respPrivKey, 
                                        sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                (<'Algorithms', 'Algorithms', vx, ax>+
                                                 <'Capabilities', 'Capabilities', vx, CR>+
                                                 <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                                 <'Get_Version', 'Get_Version', '1'>+
                                                 <'Negotiate_Algorithms', 'Negotiate_Algorithms', 
                                                  vx, a1, a2>+
                                                 <'Version', 'Version', v1.1, v2.1>), 
                                                h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                 <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                  ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                 <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                  ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                  'g'^~respPrivKey, 'NULL', 'NULL'>
                                                )
                                               >),
                                             ~ltkR), 
                                        hmac(h(<
                                                (<'Algorithms', 'Algorithms', vx, ax>+
                                                 <'Capabilities', 'Capabilities', vx, CR>+
                                                 <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                                 <'Get_Version', 'Get_Version', '1'>+
                                                 <'Negotiate_Algorithms', 'Negotiate_Algorithms', 
                                                  vx, a1, a2>+
                                                 <'Version', 'Version', v1.1, v2.1>), 
                                                h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                 <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                  ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                 <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                  ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                  'g'^~respPrivKey, 
                                                  sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                                           <'Capabilities', 'Capabilities', vx, CR>+
                                                           <'Get_Capabilities', 'Get_Capabilities', 
                                                            vx, C>+
                                                           <'Get_Version', 'Get_Version', '1'>+
                                                           <'Negotiate_Algorithms', 
                                                            'Negotiate_Algorithms', vx, a1, a2>+
                                                           <'Version', 'Version', v1.1, v2.1>), 
                                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                          (<'Finish', 'NULL'>+
                                                           <'Finish_Rsp', 'NULL'>+
                                                           <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                            vx, ~initSessionId, ~nonce, 
                                                            'g'^~newPrivKey>+
                                                           <'Key_Exchange_Resp', 
                                                            'Key_Exchange_Resp', vx, 
                                                            ~respSessionId, 'No_Mutual_auth', 
                                                            ~respNonce, 'g'^~respPrivKey, 'NULL', 
                                                            'NULL'>
                                                          )
                                                         >),
                                                       ~ltkR), 
                                                  'NULL'>
                                                )
                                               >),
                                             hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey),
                                                            'salt_o'),
                                                       h(<
                                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                                           <'Capabilities', 'Capabilities', vx, CR>+
                                                           <'Get_Capabilities', 'Get_Capabilities', 
                                                            vx, C>+
                                                           <'Get_Version', 'Get_Version', '1'>+
                                                           <'Negotiate_Algorithms', 
                                                            'Negotiate_Algorithms', vx, a1, a2>+
                                                           <'Version', 'Version', v1.1, v2.1>), 
                                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                          (<'Finish', 'NULL'>+
                                                           <'Finish_Rsp', 'NULL'>+
                                                           <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                            vx, ~initSessionId, ~nonce, 
                                                            'g'^~newPrivKey>+
                                                           <'Key_Exchange_Resp', 
                                                            'Key_Exchange_Resp', vx, 
                                                            ~respSessionId, 'No_Mutual_auth', 
                                                            ~respNonce, 'g'^~respPrivKey, 
                                                            sign(h(<vx, 
                                                                    'Key_Exchange_Resp_Signing', 
                                                                    (
                                                                     <'Algorithms', 'Algorithms', 
                                                                      vx, ax>+
                                                                     <'Capabilities', 
                                                                      'Capabilities', vx, CR>+
                                                                     <'Get_Capabilities', 
                                                                      'Get_Capabilities', vx, C>+
                                                                     <'Get_Version', 'Get_Version', 
                                                                      '1'>+
                                                                     <'Negotiate_Algorithms', 
                                                                      'Negotiate_Algorithms', vx, 
                                                                      a1, a2>+
                                                                     <'Version', 'Version', v1.1, 
                                                                      v2.1>
                                                                    ), 
                                                                    h(sign(<~oidR, pk(~ltkR)>,
                                                                           ~rootkey)), 
                                                                    (<'Finish', 'NULL'>+
                                                                     <'Finish_Rsp', 'NULL'>+
                                                                     <'Get_Key_Exchange', 
                                                                      'Get_Key_Exchange', vx, 
                                                                      ~initSessionId, ~nonce, 
                                                                      'g'^~newPrivKey>+
                                                                     <'Key_Exchange_Resp', 
                                                                      'Key_Exchange_Resp', vx, 
                                                                      ~respSessionId, 
                                                                      'No_Mutual_auth', ~respNonce, 
                                                                      'g'^~respPrivKey, 'NULL', 
                                                                      'NULL'>
                                                                    )
                                                                   >),
                                                                 ~ltkR), 
                                                            'NULL'>
                                                          )
                                                         >),
                                                       'resp_hs_data'),
                                                  vx, 'finished'))
                                       >
                                      )
                                     >),
                                   hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey), 'salt_o'),
                                             h(<
                                                (<'Algorithms', 'Algorithms', vx, ax>+
                                                 <'Capabilities', 'Capabilities', vx, CR>+
                                                 <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                                 <'Get_Version', 'Get_Version', '1'>+
                                                 <'Negotiate_Algorithms', 'Negotiate_Algorithms', 
                                                  vx, a1, a2>+
                                                 <'Version', 'Version', v1.1, v2.1>), 
                                                h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                 <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                  ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                 <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                  ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                  'g'^~respPrivKey, 
                                                  sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                                           <'Capabilities', 'Capabilities', vx, CR>+
                                                           <'Get_Capabilities', 'Get_Capabilities', 
                                                            vx, C>+
                                                           <'Get_Version', 'Get_Version', '1'>+
                                                           <'Negotiate_Algorithms', 
                                                            'Negotiate_Algorithms', vx, a1, a2>+
                                                           <'Version', 'Version', v1.1, v2.1>), 
                                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                          (<'Finish', 'NULL'>+
                                                           <'Finish_Rsp', 'NULL'>+
                                                           <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                            vx, ~initSessionId, ~nonce, 
                                                            'g'^~newPrivKey>+
                                                           <'Key_Exchange_Resp', 
                                                            'Key_Exchange_Resp', vx, 
                                                            ~respSessionId, 'No_Mutual_auth', 
                                                            ~respNonce, 'g'^~respPrivKey, 'NULL', 
                                                            'NULL'>
                                                          )
                                                         >),
                                                       ~ltkR), 
                                                  'NULL'>
                                                )
                                               >),
                                             'resp_hs_data'),
                                        vx, 'finished'))
                         ) @ #vk.27 )
                    case R_Finish_Response
                    solve( !KU( ~initSessionId ) @ #vk.53 )
                      case I_KE_Request
                      solve( !KU( ~nonce ) @ #vk.56 )
                        case I_KE_Request
                        solve( !KU( ~respSessionId ) @ #vk.29 )
                          case R_KE_Response
                          solve( !KU( ~respNonce ) @ #vk.32 )
                            case R_KE_Response
                            solve( !KU( sign(<~oidR, pk(~ltkR)>, ~rootkey) ) @ #vk.55 )
                              case A_getCertHonest
                              solve( !KU( hmac(h(<
                                                  (<'Algorithms', 'Algorithms', vx, ax>+
                                                   <'Capabilities', 'Capabilities', vx, CR>+
                                                   <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                                   <'Get_Version', 'Get_Version', '1'>+
                                                   <'Negotiate_Algorithms', 'Negotiate_Algorithms', 
                                                    vx, a1, a2>+
                                                   <'Version', 'Version', v1.1, v2.1>), 
                                                  h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                  (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                   <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                    ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                   <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                    ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                    'g'^~respPrivKey, 
                                                    sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                            (<'Algorithms', 'Algorithms', vx, ax>+
                                                             <'Capabilities', 'Capabilities', vx, CR
                                                             >+
                                                             <'Get_Capabilities', 
                                                              'Get_Capabilities', vx, C>+
                                                             <'Get_Version', 'Get_Version', '1'>+
                                                             <'Negotiate_Algorithms', 
                                                              'Negotiate_Algorithms', vx, a1, a2>+
                                                             <'Version', 'Version', v1.1, v2.1>), 
                                                            h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                            (<'Finish', 'NULL'>+
                                                             <'Finish_Rsp', 'NULL'>+
                                                             <'Get_Key_Exchange', 
                                                              'Get_Key_Exchange', vx, 
                                                              ~initSessionId, ~nonce, 
                                                              'g'^~newPrivKey>+
                                                             <'Key_Exchange_Resp', 
                                                              'Key_Exchange_Resp', vx, 
                                                              ~respSessionId, 'No_Mutual_auth', 
                                                              ~respNonce, 'g'^~respPrivKey, 'NULL', 
                                                              'NULL'>
                                                            )
                                                           >),
                                                         ~ltkR), 
                                                    'NULL'>
                                                  )
                                                 >),
                                               hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey),
                                                              'salt_o'),
                                                         h(<
                                                            (<'Algorithms', 'Algorithms', vx, ax>+
                                                             <'Capabilities', 'Capabilities', vx, CR
                                                             >+
                                                             <'Get_Capabilities', 
                                                              'Get_Capabilities', vx, C>+
                                                             <'Get_Version', 'Get_Version', '1'>+
                                                             <'Negotiate_Algorithms', 
                                                              'Negotiate_Algorithms', vx, a1, a2>+
                                                             <'Version', 'Version', v1.1, v2.1>), 
                                                            h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                            (<'Finish', 'NULL'>+
                                                             <'Finish_Rsp', 'NULL'>+
                                                             <'Get_Key_Exchange', 
                                                              'Get_Key_Exchange', vx, 
                                                              ~initSessionId, ~nonce, 
                                                              'g'^~newPrivKey>+
                                                             <'Key_Exchange_Resp', 
                                                              'Key_Exchange_Resp', vx, 
                                                              ~respSessionId, 'No_Mutual_auth', 
                                                              ~respNonce, 'g'^~respPrivKey, 
                                                              sign(h(<vx, 
                                                                      'Key_Exchange_Resp_Signing', 
                                                                      (
                                                                       <'Algorithms', 'Algorithms', 
                                                                        vx, ax>+
                                                                       <'Capabilities', 
                                                                        'Capabilities', vx, CR>+
                                                                       <'Get_Capabilities', 
                                                                        'Get_Capabilities', vx, C>+
                                                                       <'Get_Version', 
                                                                        'Get_Version', '1'>+
                                                                       <'Negotiate_Algorithms', 
                                                                        'Negotiate_Algorithms', vx, 
                                                                        a1, a2>+
                                                                       <'Version', 'Version', v1.1, 
                                                                        v2.1>
                                                                      ), 
                                                                      h(sign(<~oidR, pk(~ltkR)>,
                                                                             ~rootkey)), 
                                                                      (<'Finish', 'NULL'>+
                                                                       <'Finish_Rsp', 'NULL'>+
                                                                       <'Get_Key_Exchange', 
                                                                        'Get_Key_Exchange', vx, 
                                                                        ~initSessionId, ~nonce, 
                                                                        'g'^~newPrivKey>+
                                                                       <'Key_Exchange_Resp', 
                                                                        'Key_Exchange_Resp', vx, 
                                                                        ~respSessionId, 
                                                                        'No_Mutual_auth', 
                                                                        ~respNonce, 
                                                                        'g'^~respPrivKey, 'NULL', 
                                                                        'NULL'>
                                                                      )
                                                                     >),
                                                                   ~ltkR), 
                                                              'NULL'>
                                                            )
                                                           >),
                                                         'resp_hs_data'),
                                                    vx, 'finished'))
                                     ) @ #vk.35 )
                                case R_KE_Response
                                solve( !KU( pk(~ltkR) ) @ #vk.55 )
                                  case A_getCertHonest
                                  solve( !KU( 'g'^~newPrivKey ) @ #vk.57 )
                                    case I_KE_Request
                                    solve( !KU( 'g'^~respPrivKey ) @ #vk.38 )
                                      case R_KE_Response
                                      solve( !KU( hmac(h(<
                                                          (<'Algorithms', 'Algorithms', vx, ax>+
                                                           <'Capabilities', 'Capabilities', vx, CR>+
                                                           <'Get_Capabilities', 'Get_Capabilities', 
                                                            vx, C>+
                                                           <'Get_Version', 'Get_Version', '1'>+
                                                           <'Negotiate_Algorithms', 
                                                            'Negotiate_Algorithms', vx, a1, a2>+
                                                           <'Version', 'Version', v1.1, v2.1>), 
                                                          h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                          (<'Finish', 'Finish', vx, 'NULL'>+
                                                           <'Finish_Rsp', 'NULL'>+
                                                           <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                            vx, ~initSessionId, ~nonce, 
                                                            'g'^~newPrivKey>+
                                                           <'Key_Exchange_Resp', 
                                                            'Key_Exchange_Resp', vx, 
                                                            ~respSessionId, 'No_Mutual_auth', 
                                                            ~respNonce, 'g'^~respPrivKey, 
                                                            sign(h(<vx, 
                                                                    'Key_Exchange_Resp_Signing', 
                                                                    (
                                                                     <'Algorithms', 'Algorithms', 
                                                                      vx, ax>+
                                                                     <'Capabilities', 
                                                                      'Capabilities', vx, CR>+
                                                                     <'Get_Capabilities', 
                                                                      'Get_Capabilities', vx, C>+
                                                                     <'Get_Version', 'Get_Version', 
                                                                      '1'>+
                                                                     <'Negotiate_Algorithms', 
                                                                      'Negotiate_Algorithms', vx, 
                                                                      a1, a2>+
                                                                     <'Version', 'Version', v1.1, 
                                                                      v2.1>
                                                                    ), 
                                                                    h(sign(<~oidR, pk(~ltkR)>,
                                                                           ~rootkey)), 
                                                                    (<'Finish', 'NULL'>+
                                                                     <'Finish_Rsp', 'NULL'>+
                                                                     <'Get_Key_Exchange', 
                                                                      'Get_Key_Exchange', vx, 
                                                                      ~initSessionId, ~nonce, 
                                                                      'g'^~newPrivKey>+
                                                                     <'Key_Exchange_Resp', 
                                                                      'Key_Exchange_Resp', vx, 
                                                                      ~respSessionId, 
                                                                      'No_Mutual_auth', ~respNonce, 
                                                                      'g'^~respPrivKey, 'NULL', 
                                                                      'NULL'>
                                                                    )
                                                                   >),
                                                                 ~ltkR), 
                                                            hmac(h(<
                                                                    (
                                                                     <'Algorithms', 'Algorithms', 
                                                                      vx, ax>+
                                                                     <'Capabilities', 
                                                                      'Capabilities', vx, CR>+
                                                                     <'Get_Capabilities', 
                                                                      'Get_Capabilities', vx, C>+
                                                                     <'Get_Version', 'Get_Version', 
                                                                      '1'>+
                                                                     <'Negotiate_Algorithms', 
                                                                      'Negotiate_Algorithms', vx, 
                                                                      a1, a2>+
                                                                     <'Version', 'Version', v1.1, 
                                                                      v2.1>
                                                                    ), 
                                                                    h(sign(<~oidR, pk(~ltkR)>,
                                                                           ~rootkey)), 
                                                                    (<'Finish', 'NULL'>+
                                                                     <'Finish_Rsp', 'NULL'>+
                                                                     <'Get_Key_Exchange', 
                                                                      'Get_Key_Exchange', vx, 
                                                                      ~initSessionId, ~nonce, 
                                                                      'g'^~newPrivKey>+
                                                                     <'Key_Exchange_Resp', 
                                                                      'Key_Exchange_Resp', vx, 
                                                                      ~respSessionId, 
                                                                      'No_Mutual_auth', ~respNonce, 
                                                                      'g'^~respPrivKey, 
                                                                      sign(h(<vx, 
                                                                              'Key_Exchange_Resp_Signing', 
                                                                              (
                                                                               <'Algorithms', 
                                                                                'Algorithms', vx, ax
                                                                               >+
                                                                               <'Capabilities', 
                                                                                'Capabilities', vx, 
                                                                                CR>+
                                                                               <'Get_Capabilities', 
                                                                                'Get_Capabilities', 
                                                                                vx, C>+
                                                                               <'Get_Version', 
                                                                                'Get_Version', '1'>+
                                                                               <
                                                                                'Negotiate_Algorithms', 
                                                                                'Negotiate_Algorithms', 
                                                                                vx, a1, a2>+
                                                                               <'Version', 
                                                                                'Version', v1.1, 
                                                                                v2.1>
                                                                              ), 
                                                                              h(sign(<~oidR, 
                                                                                      pk(~ltkR)>,
                                                                                     ~rootkey)), 
                                                                              (<'Finish', 'NULL'>+
                                                                               <'Finish_Rsp', 'NULL'
                                                                               >+
                                                                               <'Get_Key_Exchange', 
                                                                                'Get_Key_Exchange', 
                                                                                vx, ~initSessionId, 
                                                                                ~nonce, 
                                                                                'g'^~newPrivKey>+
                                                                               <
                                                                                'Key_Exchange_Resp', 
                                                                                'Key_Exchange_Resp', 
                                                                                vx, ~respSessionId, 
                                                                                'No_Mutual_auth', 
                                                                                ~respNonce, 
                                                                                'g'^~respPrivKey, 
                                                                                'NULL', 'NULL'>
                                                                              )
                                                                             >),
                                                                           ~ltkR), 
                                                                      'NULL'>
                                                                    )
                                                                   >),
                                                                 hkdf(hkdf(hmac('g'^(~newPrivKey*
                                                                                     ~respPrivKey),
                                                                                'salt_o'),
                                                                           h(<
                                                                              (
                                                                               <'Algorithms', 
                                                                                'Algorithms', vx, ax
                                                                               >+
                                                                               <'Capabilities', 
                                                                                'Capabilities', vx, 
                                                                                CR>+
                                                                               <'Get_Capabilities', 
                                                                                'Get_Capabilities', 
                                                                                vx, C>+
                                                                               <'Get_Version', 
                                                                                'Get_Version', '1'>+
                                                                               <
                                                                                'Negotiate_Algorithms', 
                                                                                'Negotiate_Algorithms', 
                                                                                vx, a1, a2>+
                                                                               <'Version', 
                                                                                'Version', v1.1, 
                                                                                v2.1>
                                                                              ), 
                                                                              h(sign(<~oidR, 
                                                                                      pk(~ltkR)>,
                                                                                     ~rootkey)), 
                                                                              (<'Finish', 'NULL'>+
                                                                               <'Finish_Rsp', 'NULL'
                                                                               >+
                                                                               <'Get_Key_Exchange', 
                                                                                'Get_Key_Exchange', 
                                                                                vx, ~initSessionId, 
                                                                                ~nonce, 
                                                                                'g'^~newPrivKey>+
                                                                               <
                                                                                'Key_Exchange_Resp', 
                                                                                'Key_Exchange_Resp', 
                                                                                vx, ~respSessionId, 
                                                                                'No_Mutual_auth', 
                                                                                ~respNonce, 
                                                                                'g'^~respPrivKey, 
                                                                                sign(h(<vx, 
                                                                                        'Key_Exchange_Resp_Signing', 
                                                                                        (
                                                                                         <
                                                                                          'Algorithms', 
                                                                                          'Algorithms', 
                                                                                          vx, ax>+
                                                                                         <
                                                                                          'Capabilities', 
                                                                                          'Capabilities', 
                                                                                          vx, CR>+
                                                                                         <
                                                                                          'Get_Capabilities', 
                                                                                          'Get_Capabilities', 
                                                                                          vx, C>+
                                                                                         <
                                                                                          'Get_Version', 
                                                                                          'Get_Version', 
                                                                                          '1'>+
                                                                                         <
                                                                                          'Negotiate_Algorithms', 
                                                                                          'Negotiate_Algorithms', 
                                                                                          vx, a1, a2
                                                                                         >+
                                                                                         <
                                                                                          'Version', 
                                                                                          'Version', 
                                                                                          v1.1, v2.1
                                                                                         >
                                                                                        ), 
                                                                                        h(sign(<
                                                                                                ~oidR, 
                                                                                                pk(~ltkR)
                                                                                               >,
                                                                                               ~rootkey)), 
                                                                                        (
                                                                                         <'Finish', 
                                                                                          'NULL'>+
                                                                                         <
                                                                                          'Finish_Rsp', 
                                                                                          'NULL'>+
                                                                                         <
                                                                                          'Get_Key_Exchange', 
                                                                                          'Get_Key_Exchange', 
                                                                                          vx, 
                                                                                          ~initSessionId, 
                                                                                          ~nonce, 
                                                                                          'g'^~newPrivKey
                                                                                         >+
                                                                                         <
                                                                                          'Key_Exchange_Resp', 
                                                                                          'Key_Exchange_Resp', 
                                                                                          vx, 
                                                                                          ~respSessionId, 
                                                                                          'No_Mutual_auth', 
                                                                                          ~respNonce, 
                                                                                          'g'^~respPrivKey, 
                                                                                          'NULL', 
                                                                                          'NULL'>
                                                                                        )
                                                                                       >),
                                                                                     ~ltkR), 
                                                                                'NULL'>
                                                                              )
                                                                             >),
                                                                           'resp_hs_data'),
                                                                      vx, 'finished'))
                                                           >
                                                          )
                                                         >),
                                                       hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey
                                                                          ),
                                                                      'salt_o'),
                                                                 h(<
                                                                    (
                                                                     <'Algorithms', 'Algorithms', 
                                                                      vx, ax>+
                                                                     <'Capabilities', 
                                                                      'Capabilities', vx, CR>+
                                                                     <'Get_Capabilities', 
                                                                      'Get_Capabilities', vx, C>+
                                                                     <'Get_Version', 'Get_Version', 
                                                                      '1'>+
                                                                     <'Negotiate_Algorithms', 
                                                                      'Negotiate_Algorithms', vx, 
                                                                      a1, a2>+
                                                                     <'Version', 'Version', v1.1, 
                                                                      v2.1>
                                                                    ), 
                                                                    h(sign(<~oidR, pk(~ltkR)>,
                                                                           ~rootkey)), 
                                                                    (<'Finish', 'NULL'>+
                                                                     <'Finish_Rsp', 'NULL'>+
                                                                     <'Get_Key_Exchange', 
                                                                      'Get_Key_Exchange', vx, 
                                                                      ~initSessionId, ~nonce, 
                                                                      'g'^~newPrivKey>+
                                                                     <'Key_Exchange_Resp', 
                                                                      'Key_Exchange_Resp', vx, 
                                                                      ~respSessionId, 
                                                                      'No_Mutual_auth', ~respNonce, 
                                                                      'g'^~respPrivKey, 
                                                                      sign(h(<vx, 
                                                                              'Key_Exchange_Resp_Signing', 
                                                                              (
                                                                               <'Algorithms', 
                                                                                'Algorithms', vx, ax
                                                                               >+
                                                                               <'Capabilities', 
                                                                                'Capabilities', vx, 
                                                                                CR>+
                                                                               <'Get_Capabilities', 
                                                                                'Get_Capabilities', 
                                                                                vx, C>+
                                                                               <'Get_Version', 
                                                                                'Get_Version', '1'>+
                                                                               <
                                                                                'Negotiate_Algorithms', 
                                                                                'Negotiate_Algorithms', 
                                                                                vx, a1, a2>+
                                                                               <'Version', 
                                                                                'Version', v1.1, 
                                                                                v2.1>
                                                                              ), 
                                                                              h(sign(<~oidR, 
                                                                                      pk(~ltkR)>,
                                                                                     ~rootkey)), 
                                                                              (<'Finish', 'NULL'>+
                                                                               <'Finish_Rsp', 'NULL'
                                                                               >+
                                                                               <'Get_Key_Exchange', 
                                                                                'Get_Key_Exchange', 
                                                                                vx, ~initSessionId, 
                                                                                ~nonce, 
                                                                                'g'^~newPrivKey>+
                                                                               <
                                                                                'Key_Exchange_Resp', 
                                                                                'Key_Exchange_Resp', 
                                                                                vx, ~respSessionId, 
                                                                                'No_Mutual_auth', 
                                                                                ~respNonce, 
                                                                                'g'^~respPrivKey, 
                                                                                'NULL', 'NULL'>
                                                                              )
                                                                             >),
                                                                           ~ltkR), 
                                                                      'NULL'>
                                                                    )
                                                                   >),
                                                                 'init_hs_data'),
                                                            vx, 'finished'))
                                             ) @ #vk.71 )
                                        case I_Finish_Request
                                        SOLVED // trace found
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  next
                    case c_hmac
                    by sorry
                  qed
                next
                  case R_EncapsResponseAck_RecvCertificate
                  by contradiction /* cyclic */
                next
                  case R_Spawn_new_PK_Session
                  by contradiction /* cyclic */
                qed
              next
                case c_sign
                by sorry
              qed
            next
              case I_Spawn_new_PK_Session
              by contradiction /* cyclic */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma can_reach_fin_resp [heuristic=S, hide_lemma=ICertOrigin,
                          hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #i4 #j #j2 #j3.
    ((((((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                       (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                      (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                     (StartFinishKE( sid, tid, oid, oidR ) @ #i4)) ∧
                    (RespReachVCA( tid2, oid, oidR ) @ #j)) ∧
                   (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2)) ∧
                  (RespFinish( sid2, tid2, oid, oidR ) @ #j3)) ∧
                 (#i < #i2)) ∧
                (#i2 < #i3)) ∧
               (#i3 < #i4)) ∧
              (#j < #j2)) ∧
             (#j2 < #j3)) ∧
            (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
           (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
             ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
              (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
            ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
             (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
           ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
          ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
           (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
         ((StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
        ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
       ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
      ((RespFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (RespFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #i4 #j #j2 #j3.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (StartFinishKE( sid, tid, oid, oidR ) @ #i4) ∧
  (RespReachVCA( tid2, oid, oidR ) @ #j) ∧
  (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2) ∧
  (RespFinish( sid2, tid2, oid, oidR ) @ #j3)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#i3 < #i4) ∧
  (#j < #j2) ∧
  (#j2 < #j3) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (RespFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RespFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_reach_encap_digest_init [heuristic=S,
                                   hide_lemma=ICertOrigin, hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2 #i3 #i6.
    ((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                 (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
               (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6)) ∧
              (#i < #i2)) ∧
             (#i2 < #i3)) ∧
            (#i3 < #i6)) ∧
           (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
          (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
            ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
             (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
           ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
            (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
          ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
           (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
         ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
          (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
        ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
       ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
      ((SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2 #i3 #i6.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#i3 < #i6) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
simplify
solve( StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
                  (<'Algorithms', 'NULL'>+<'Capabilities', c>+
                   <'Get_Capabilities', gc>+<'Get_Version', gv>+
                   <'Negotiate_Algorithms', ga>+<'Version', v>),
                  optionsTranscript, 'NULL', 'NULL', 'START_GETALGORITHMS'
       ) ▶₀ #i )
  case I_Algorithms_Request
  solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pkR, digestR,
                          version, VCATrancriptI,
                          (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                           <'Key_Exchange_Resp', ker>),
                          'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
         ) ▶₀ #i2 )
    case I_Spawn_new_PK_Session
    solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pk(~ltkR), digest,
                            version.1, VCATrancriptI.1,
                            (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                             <'Key_Exchange_Resp', rsp>),
                            ~privKey, ~initSessionId.1, 'NULL', 'NULL', 'NULL', 'NULL',
                            'WAIT_KEY_RESP'
           ) ▶₀ #i3 )
      case I_KE_Request
      solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, somepkR, digest,
                              version.1, VCATranscript,
                              (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                               <'Key_Exchange_Resp', ker>),
                              ~privKey, ~initSessionId.1, handshake_secret, init_finished_key,
                              resp_finished_key, bindSid, 'AFTER_KE'
             ) ▶₀ #i6 )
        case I_KE_ProcessAndVerify
        solve( !Cert( ~oid, pk(~ltkI), certI ) ▶₁ #i6 )
          case A_getCertHonest
          solve( StateInit( ~tid, ~oid, ~oidR, version, axI, <VI, CI, AI>,
                            VCATrancriptI, optionsTranscriptI, somePKR, digestR, 'IDLE'
                 ) ▶₀ #vr.5 )
            case I_Algorithms_ProcessResponse
            solve( !KU( sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                (<'Algorithms', 'Algorithms', vx, ax>+
                                 <'Capabilities', 'Capabilities', vx, CR>+
                                 <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                 <'Get_Version', 'Get_Version', '1'>+
                                 <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                 <'Version', 'Version', VR>), 
                                h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                 <'Get_Key_Exchange', 'Get_Key_Exchange', vx, ~initSessionId, 
                                  ~nonce, 'g'^~newPrivKey>+
                                 <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, respSessionId, 
                                  'No_Mutual_auth', respNonce, respPublicKey, 'NULL', 'NULL'>
                                )
                               >),
                             ~ltkR)
                   ) @ #vk.18 )
              case R_KE_Response
              solve( StateResp( ~tidR, ~oidI, ~oidR, vx, axR, <VR.1, CR.2, AR>,
                                (<'Algorithms', 'Algorithms', vx, ax>+
                                 <'Capabilities', 'Capabilities', vx, CR>+
                                 <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                 <'Get_Version', 'Get_Version', '1'>+
                                 <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                 <'Version', 'Version', VR>),
                                optionsTranscriptR, somepkI, somedigestI, 'IDLE'
                     ) ▶₀ #vr.16 )
                case R_Algorithms_Response
                solve( !KU( ~initSessionId ) @ #vk.46 )
                  case I_KE_Request
                  solve( !KU( ~nonce ) @ #vk.50 )
                    case I_KE_Request
                    solve( !KU( ~respSessionId ) @ #vk.24 )
                      case R_KE_Response
                      solve( !KU( ~respNonce ) @ #vk.27 )
                        case R_KE_Response
                        solve( !KU( sign(<~oidR, pk(~ltkR)>, ~rootkey) ) @ #vk.49 )
                          case A_getCertHonest
                          solve( !KU( hmac(h(<
                                              (<'Algorithms', 'Algorithms', vx, ax>+
                                               <'Capabilities', 'Capabilities', vx, CR>+
                                               <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                               <'Get_Version', 'Get_Version', '1'>+
                                               <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, 
                                                a1, a2>+
                                               <'Version', 'Version', v1.1, v2.1>), 
                                              h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                              (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                               <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                               <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                'g'^~respPrivKey, 
                                                sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                        (<'Algorithms', 'Algorithms', vx, ax>+
                                                         <'Capabilities', 'Capabilities', vx, CR>+
                                                         <'Get_Capabilities', 'Get_Capabilities', 
                                                          vx, C>+
                                                         <'Get_Version', 'Get_Version', '1'>+
                                                         <'Negotiate_Algorithms', 
                                                          'Negotiate_Algorithms', vx, a1, a2>+
                                                         <'Version', 'Version', v1.1, v2.1>), 
                                                        h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                        (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                         <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                          vx, ~initSessionId, ~nonce, 
                                                          'g'^~newPrivKey>+
                                                         <'Key_Exchange_Resp', 'Key_Exchange_Resp', 
                                                          vx, ~respSessionId, 'No_Mutual_auth', 
                                                          ~respNonce, 'g'^~respPrivKey, 'NULL', 
                                                          'NULL'>
                                                        )
                                                       >),
                                                     ~ltkR), 
                                                'NULL'>
                                              )
                                             >),
                                           hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey), 'salt_o'),
                                                     h(<
                                                        (<'Algorithms', 'Algorithms', vx, ax>+
                                                         <'Capabilities', 'Capabilities', vx, CR>+
                                                         <'Get_Capabilities', 'Get_Capabilities', 
                                                          vx, C>+
                                                         <'Get_Version', 'Get_Version', '1'>+
                                                         <'Negotiate_Algorithms', 
                                                          'Negotiate_Algorithms', vx, a1, a2>+
                                                         <'Version', 'Version', v1.1, v2.1>), 
                                                        h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                        (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                         <'Get_Key_Exchange', 'Get_Key_Exchange', 
                                                          vx, ~initSessionId, ~nonce, 
                                                          'g'^~newPrivKey>+
                                                         <'Key_Exchange_Resp', 'Key_Exchange_Resp', 
                                                          vx, ~respSessionId, 'No_Mutual_auth', 
                                                          ~respNonce, 'g'^~respPrivKey, 
                                                          sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                                  (
                                                                   <'Algorithms', 'Algorithms', vx, 
                                                                    ax>+
                                                                   <'Capabilities', 'Capabilities', 
                                                                    vx, CR>+
                                                                   <'Get_Capabilities', 
                                                                    'Get_Capabilities', vx, C>+
                                                                   <'Get_Version', 'Get_Version', 
                                                                    '1'>+
                                                                   <'Negotiate_Algorithms', 
                                                                    'Negotiate_Algorithms', vx, a1, 
                                                                    a2>+
                                                                   <'Version', 'Version', v1.1, v2.1
                                                                   >
                                                                  ), 
                                                                  h(sign(<~oidR, pk(~ltkR)>,
                                                                         ~rootkey)), 
                                                                  (<'Finish', 'NULL'>+
                                                                   <'Finish_Rsp', 'NULL'>+
                                                                   <'Get_Key_Exchange', 
                                                                    'Get_Key_Exchange', vx, 
                                                                    ~initSessionId, ~nonce, 
                                                                    'g'^~newPrivKey>+
                                                                   <'Key_Exchange_Resp', 
                                                                    'Key_Exchange_Resp', vx, 
                                                                    ~respSessionId, 
                                                                    'No_Mutual_auth', ~respNonce, 
                                                                    'g'^~respPrivKey, 'NULL', 'NULL'
                                                                   >
                                                                  )
                                                                 >),
                                                               ~ltkR), 
                                                          'NULL'>
                                                        )
                                                       >),
                                                     'resp_hs_data'),
                                                vx, 'finished'))
                                 ) @ #vk.30 )
                            case R_KE_Response
                            solve( !KU( pk(~ltkR) ) @ #vk.49 )
                              case A_getCertHonest
                              solve( !KU( 'g'^~newPrivKey ) @ #vk.51 )
                                case I_KE_Request
                                solve( !KU( 'g'^~respPrivKey ) @ #vk.33 )
                                  case R_KE_Response
                                  SOLVED // trace found
                                qed
                              qed
                            qed
                          next
                            case c_hmac
                            by sorry
                          qed
                        next
                          case I_DeliverEncap_SendCertificate
                          by contradiction /* cyclic */
                        next
                          case c_sign
                          by sorry
                        qed
                      qed
                    qed
                  qed
                qed
              next
                case R_EncapsResponseAck_RecvCertificate
                by contradiction /* cyclic */
              next
                case R_Spawn_new_PK_Session
                by contradiction /* cyclic */
              qed
            next
              case c_sign
              by sorry
            qed
          next
            case I_Spawn_new_PK_Session
            by contradiction /* cyclic */
          qed
        qed
      qed
    qed
  qed
qed

lemma can_reach_encap_digest_resp [heuristic=S,
                                   hide_lemma=ICertOrigin, hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #j #j2 #j3.
    ((((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                     (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                    (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                   (RespReachVCA( tid2, oid, oidR ) @ #j)) ∧
                  (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2)) ∧
                 (ReceivedEncapsulatedDigest( sid2, tid2, oid, oidR ) @ #j3)) ∧
                (#i < #i2)) ∧
               (#i2 < #i3)) ∧
              (#j < #j2)) ∧
             (#j2 < #j3)) ∧
            (¬(∃ ltk pk1 #t. Attacker( oid, ltk, pk1 ) @ #t))) ∧
           (¬(∃ #t. StartFinishKE( sid, tid, oid, oidR ) @ #t))) ∧
          (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
            ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
             (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
           ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
            (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
          ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
           (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
         ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
          (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
        ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
       ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
      ((ReceivedEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (ReceivedEncapsulatedDigest( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #j #j2 #j3.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (RespReachVCA( tid2, oid, oidR ) @ #j) ∧
  (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2) ∧
  (ReceivedEncapsulatedDigest( sid2, tid2, oid, oidR ) @ #j3)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#j < #j2) ∧
  (#j2 < #j3) ∧
  (∀ ltk pk1 #t. (Attacker( oid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ #t. (StartFinishKE( sid, tid, oid, oidR ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceivedEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceivedEncapsulatedDigest( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
simplify
solve( StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
                  (<'Algorithms', 'NULL'>+<'Capabilities', c>+
                   <'Get_Capabilities', gc>+<'Get_Version', gv>+
                   <'Negotiate_Algorithms', ga>+<'Version', v>),
                  optionsTranscript, 'NULL', 'NULL', 'START_GETALGORITHMS'
       ) ▶₀ #i )
  case I_Algorithms_Request
  solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pkR, digestR,
                          version, VCATrancriptI,
                          (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                           <'Key_Exchange_Resp', ker>),
                          'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
         ) ▶₀ #i2 )
    case I_Spawn_new_PK_Session
    solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pk(~ltkR), digest,
                            version.1, VCATrancriptI.1,
                            (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                             <'Key_Exchange_Resp', rsp>),
                            ~privKey, ~initSessionId.1, 'NULL', 'NULL', 'NULL', 'NULL',
                            'WAIT_KEY_RESP'
           ) ▶₀ #i3 )
      case I_KE_Request
      solve( StateResp( ~tid.1, ~oid, ~oidR, vx.1, 'NULL', <V, C.1, A>,
                        (<'Algorithms', 'NULL'>+<'Capabilities', c>+
                         <'Get_Capabilities', gc>+<'Get_Version', gv>+
                         <'Negotiate_Algorithms', 'NULL'>+<'Version', v>),
                        optionsTranscript, 'NULL', 'NULL', 'RESP_GETCAPABILITIES'
             ) ▶₀ #j )
        case R_Capabilities_Response
        solve( KeyExchangeResp( ~sid.1, ~tid.1, ~oid, ~oidR, somepkI,
                                somedigestI, version.1, VCATrancript,
                                (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                                 <'Key_Exchange_Resp', ker>),
                                'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
               ) ▶₀ #j2 )
          case R_Spawn_new_PK_Session
          solve( !Cert( ~oidR, pk(~ltkR.1), certR ) ▶₁ #j2 )
            case A_getCertHonest
            solve( KeyExchangeResp( ~sid.1, ~tid.1, ~oid, ~oidR, somepkI.1,
                                    somedigestI.1, version.2, VCATrancript.1,
                                    (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                                     <'Key_Exchange_Resp', ker>),
                                    'NULL', handshake_secret, resp_finished_key, init_finished_key,
                                    bindSid, 'AFTER_KE'
                   ) ▶₀ #j3 )
              case R_KE_Response
              solve( StateInit( ~tid, ~oid, ~oidR, version, axI,
                                <VI, CI.1, AI.1>, VCATrancriptI, optionsTranscriptI, somePKR,
                                digestR, 'IDLE'
                     ) ▶₀ #vr.5 )
                case I_Algorithms_ProcessResponse
                solve( StateResp( ~tid.1, ~oid, ~oidR, version, axR,
                                  <VR.1, CR.1, AR>, VCATrancript, optionsTranscriptR, somepkI,
                                  somedigestI, 'IDLE'
                       ) ▶₀ #vr.9 )
                  case R_Algorithms_Response
                  solve( !KU( sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                      (<'Algorithms', 'Algorithms', vx, ax>+
                                       <'Capabilities', 'Capabilities', vx, CR>+
                                       <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                       <'Get_Version', 'Get_Version', '1'>+
                                       <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                       <'Version', 'Version', VR>), 
                                      h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                      (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                       <'Get_Key_Exchange', 'Get_Key_Exchange', vx, ~initSessionId, 
                                        ~nonce, 'g'^~newPrivKey>+
                                       <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                        respSessionId, 'No_Mutual_auth', respNonce, respPublicKey, 
                                        'NULL', 'NULL'>
                                      )
                                     >),
                                   ~ltkR)
                         ) @ #vk.18 )
                    case R_KE_Response
                    solve( !KU( ~initSessionId ) @ #vk.32 )
                      case I_KE_Request
                      solve( !KU( ~nonce ) @ #vk.34 )
                        case I_KE_Request
                        solve( !KU( ~respSessionId ) @ #vk.26 )
                          case R_KE_Response
                          solve( !KU( ~respNonce ) @ #vk.29 )
                            case R_KE_Response
                            solve( !KU( sign(<~oidR, pk(~ltkR)>, ~rootkey) ) @ #vk.56 )
                              case A_getCertHonest
                              solve( !KU( hmac(h(<
                                                  (<'Algorithms', 'Algorithms', vx, ax>+
                                                   <'Capabilities', 'Capabilities', vx, CR>+
                                                   <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                                   <'Get_Version', 'Get_Version', '1'>+
                                                   <'Negotiate_Algorithms', 'Negotiate_Algorithms', 
                                                    vx, a1, a2>+
                                                   <'Version', 'Version', v1.1, v2.1>), 
                                                  h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                  (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                   <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                    ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                   <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                    ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                    'g'^~respPrivKey, 
                                                    sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                            (<'Algorithms', 'Algorithms', vx, ax>+
                                                             <'Capabilities', 'Capabilities', vx, CR
                                                             >+
                                                             <'Get_Capabilities', 
                                                              'Get_Capabilities', vx, C>+
                                                             <'Get_Version', 'Get_Version', '1'>+
                                                             <'Negotiate_Algorithms', 
                                                              'Negotiate_Algorithms', vx, a1, a2>+
                                                             <'Version', 'Version', v1.1, v2.1>), 
                                                            h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                            (<'Finish', 'NULL'>+
                                                             <'Finish_Rsp', 'NULL'>+
                                                             <'Get_Key_Exchange', 
                                                              'Get_Key_Exchange', vx, 
                                                              ~initSessionId, ~nonce, 
                                                              'g'^~newPrivKey>+
                                                             <'Key_Exchange_Resp', 
                                                              'Key_Exchange_Resp', vx, 
                                                              ~respSessionId, 'No_Mutual_auth', 
                                                              ~respNonce, 'g'^~respPrivKey, 'NULL', 
                                                              'NULL'>
                                                            )
                                                           >),
                                                         ~ltkR), 
                                                    'NULL'>
                                                  )
                                                 >),
                                               hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey),
                                                              'salt_o'),
                                                         h(<
                                                            (<'Algorithms', 'Algorithms', vx, ax>+
                                                             <'Capabilities', 'Capabilities', vx, CR
                                                             >+
                                                             <'Get_Capabilities', 
                                                              'Get_Capabilities', vx, C>+
                                                             <'Get_Version', 'Get_Version', '1'>+
                                                             <'Negotiate_Algorithms', 
                                                              'Negotiate_Algorithms', vx, a1, a2>+
                                                             <'Version', 'Version', v1.1, v2.1>), 
                                                            h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                            (<'Finish', 'NULL'>+
                                                             <'Finish_Rsp', 'NULL'>+
                                                             <'Get_Key_Exchange', 
                                                              'Get_Key_Exchange', vx, 
                                                              ~initSessionId, ~nonce, 
                                                              'g'^~newPrivKey>+
                                                             <'Key_Exchange_Resp', 
                                                              'Key_Exchange_Resp', vx, 
                                                              ~respSessionId, 'No_Mutual_auth', 
                                                              ~respNonce, 'g'^~respPrivKey, 
                                                              sign(h(<vx, 
                                                                      'Key_Exchange_Resp_Signing', 
                                                                      (
                                                                       <'Algorithms', 'Algorithms', 
                                                                        vx, ax>+
                                                                       <'Capabilities', 
                                                                        'Capabilities', vx, CR>+
                                                                       <'Get_Capabilities', 
                                                                        'Get_Capabilities', vx, C>+
                                                                       <'Get_Version', 
                                                                        'Get_Version', '1'>+
                                                                       <'Negotiate_Algorithms', 
                                                                        'Negotiate_Algorithms', vx, 
                                                                        a1, a2>+
                                                                       <'Version', 'Version', v1.1, 
                                                                        v2.1>
                                                                      ), 
                                                                      h(sign(<~oidR, pk(~ltkR)>,
                                                                             ~rootkey)), 
                                                                      (<'Finish', 'NULL'>+
                                                                       <'Finish_Rsp', 'NULL'>+
                                                                       <'Get_Key_Exchange', 
                                                                        'Get_Key_Exchange', vx, 
                                                                        ~initSessionId, ~nonce, 
                                                                        'g'^~newPrivKey>+
                                                                       <'Key_Exchange_Resp', 
                                                                        'Key_Exchange_Resp', vx, 
                                                                        ~respSessionId, 
                                                                        'No_Mutual_auth', 
                                                                        ~respNonce, 
                                                                        'g'^~respPrivKey, 'NULL', 
                                                                        'NULL'>
                                                                      )
                                                                     >),
                                                                   ~ltkR), 
                                                              'NULL'>
                                                            )
                                                           >),
                                                         'resp_hs_data'),
                                                    vx, 'finished'))
                                     ) @ #vk.32 )
                                case R_KE_Response
                                solve( !KU( pk(~ltkR) ) @ #vk.56 )
                                  case A_getCertHonest
                                  solve( !KU( 'g'^~newPrivKey ) @ #vk.38 )
                                    case I_KE_Request
                                    solve( !KU( 'g'^~respPrivKey ) @ #vk.35 )
                                      case R_KE_Response
                                      SOLVED // trace found
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  next
                    case c_sign
                    by sorry
                  qed
                next
                  case R_EncapsResponseAck_RecvCertificate
                  by contradiction /* cyclic */
                next
                  case R_Spawn_new_PK_Session
                  by contradiction /* cyclic */
                qed
              next
                case I_Spawn_new_PK_Session
                by contradiction /* cyclic */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma can_reach_encap_cert_init [heuristic=S,
                                 hide_lemma=ICertOrigin, hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2 #i3 #i6 #i7.
    ((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                   (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                 (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6)) ∧
                (SendEncapsulatedCertificate( sid, tid, oid, oidR ) @ #i7)) ∧
               (#i < #i2)) ∧
              (#i2 < #i3)) ∧
             (#i3 < #i6)) ∧
            (#i6 < #i7)) ∧
           (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
          (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
            ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
             (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
           ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
            (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
          ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
           (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
         ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
          (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
        ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
       ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
      ((SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2 #i3 #i6 #i7.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6) ∧
  (SendEncapsulatedCertificate( sid, tid, oid, oidR ) @ #i7)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#i3 < #i6) ∧
  (#i6 < #i7) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
simplify
solve( StateInit( ~tid, ~oid, ~oidR, vx, 'NULL', <V, C, A>,
                  (<'Algorithms', 'NULL'>+<'Capabilities', c>+
                   <'Get_Capabilities', gc>+<'Get_Version', gv>+
                   <'Negotiate_Algorithms', ga>+<'Version', v>),
                  optionsTranscript, 'NULL', 'NULL', 'START_GETALGORITHMS'
       ) ▶₀ #i )
  case I_Algorithms_Request
  solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pkR, digestR,
                          version, VCATrancriptI,
                          (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                           <'Key_Exchange_Resp', ker>),
                          'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'NULL', 'START_KE'
         ) ▶₀ #i2 )
    case I_Spawn_new_PK_Session
    solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, pk(~ltkR), digest,
                            version.1, VCATrancriptI.1,
                            (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                             <'Key_Exchange_Resp', rsp>),
                            ~privKey, ~initSessionId.1, 'NULL', 'NULL', 'NULL', 'NULL',
                            'WAIT_KEY_RESP'
           ) ▶₀ #i3 )
      case I_KE_Request
      solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, somepkR, digest,
                              version.1, VCATranscript,
                              (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                               <'Key_Exchange_Resp', ker>),
                              ~privKey, ~initSessionId.1, handshake_secret, init_finished_key,
                              resp_finished_key, bindSid, 'AFTER_KE'
             ) ▶₀ #i6 )
        case I_KE_ProcessAndVerify
        solve( !Cert( ~oid, pk(~ltkI), certI ) ▶₁ #i6 )
          case A_getCertHonest
          solve( KeyExchangeInit( ~sid, ~tid, ~oid, ~oidR, somepkR, digest,
                                  version.1, VCATranscript,
                                  (<'Finish', f>+<'Finish_Rsp', fr>+<'Get_Key_Exchange', gke>+
                                   <'Key_Exchange_Resp', ker>),
                                  ~privKey, ~initSessionId.1, handshake_secret, init_finished_key,
                                  resp_finished_key, bindSid, 'SENT_DIGEST'
                 ) ▶₀ #i7 )
            case I_DeliverEncap_SendDigest
            solve( !Cert( ~oid, pk(~ltkI.1), certI ) ▶₂ #i7 )
              case A_getCertHonest
              solve( StateInit( ~tid, ~oid, ~oidR, version, axI, <VI, CI, AI>,
                                VCATrancriptI, optionsTranscriptI, somePKR, digestR, 'IDLE'
                     ) ▶₀ #vr.5 )
                case I_Algorithms_ProcessResponse
                solve( !KU( sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                    (<'Algorithms', 'Algorithms', vx, ax>+
                                     <'Capabilities', 'Capabilities', vx, CR>+
                                     <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                     <'Get_Version', 'Get_Version', '1'>+
                                     <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                     <'Version', 'Version', VR>), 
                                    h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                    (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                     <'Get_Key_Exchange', 'Get_Key_Exchange', vx, ~initSessionId, 
                                      ~nonce, 'g'^~newPrivKey>+
                                     <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, respSessionId, 
                                      'No_Mutual_auth', respNonce, respPublicKey, 'NULL', 'NULL'>
                                    )
                                   >),
                                 ~ltkR)
                       ) @ #vk.19 )
                  case R_KE_Response
                  solve( StateResp( ~tidR, ~oidI, ~oidR, vx, axR, <VR.1, CR.2, AR>,
                                    (<'Algorithms', 'Algorithms', vx, ax>+
                                     <'Capabilities', 'Capabilities', vx, CR>+
                                     <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                     <'Get_Version', 'Get_Version', '1'>+
                                     <'Negotiate_Algorithms', 'Negotiate_Algorithms', vx, a1, a2>+
                                     <'Version', 'Version', VR>),
                                    optionsTranscriptR, somepkI, somedigestI, 'IDLE'
                         ) ▶₀ #vr.16 )
                    case R_Algorithms_Response
                    solve( !KU( ~initSessionId ) @ #vk.48 )
                      case I_KE_Request
                      solve( !KU( ~nonce ) @ #vk.52 )
                        case I_KE_Request
                        solve( !KU( ~respSessionId ) @ #vk.25 )
                          case R_KE_Response
                          solve( !KU( ~respNonce ) @ #vk.28 )
                            case R_KE_Response
                            solve( !KU( sign(<~oidR, pk(~ltkR)>, ~rootkey) ) @ #vk.51 )
                              case A_getCertHonest
                              solve( !KU( hmac(h(<
                                                  (<'Algorithms', 'Algorithms', vx, ax>+
                                                   <'Capabilities', 'Capabilities', vx, CR>+
                                                   <'Get_Capabilities', 'Get_Capabilities', vx, C>+
                                                   <'Get_Version', 'Get_Version', '1'>+
                                                   <'Negotiate_Algorithms', 'Negotiate_Algorithms', 
                                                    vx, a1, a2>+
                                                   <'Version', 'Version', v1.1, v2.1>), 
                                                  h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                  (<'Finish', 'NULL'>+<'Finish_Rsp', 'NULL'>+
                                                   <'Get_Key_Exchange', 'Get_Key_Exchange', vx, 
                                                    ~initSessionId, ~nonce, 'g'^~newPrivKey>+
                                                   <'Key_Exchange_Resp', 'Key_Exchange_Resp', vx, 
                                                    ~respSessionId, 'No_Mutual_auth', ~respNonce, 
                                                    'g'^~respPrivKey, 
                                                    sign(h(<vx, 'Key_Exchange_Resp_Signing', 
                                                            (<'Algorithms', 'Algorithms', vx, ax>+
                                                             <'Capabilities', 'Capabilities', vx, CR
                                                             >+
                                                             <'Get_Capabilities', 
                                                              'Get_Capabilities', vx, C>+
                                                             <'Get_Version', 'Get_Version', '1'>+
                                                             <'Negotiate_Algorithms', 
                                                              'Negotiate_Algorithms', vx, a1, a2>+
                                                             <'Version', 'Version', v1.1, v2.1>), 
                                                            h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                            (<'Finish', 'NULL'>+
                                                             <'Finish_Rsp', 'NULL'>+
                                                             <'Get_Key_Exchange', 
                                                              'Get_Key_Exchange', vx, 
                                                              ~initSessionId, ~nonce, 
                                                              'g'^~newPrivKey>+
                                                             <'Key_Exchange_Resp', 
                                                              'Key_Exchange_Resp', vx, 
                                                              ~respSessionId, 'No_Mutual_auth', 
                                                              ~respNonce, 'g'^~respPrivKey, 'NULL', 
                                                              'NULL'>
                                                            )
                                                           >),
                                                         ~ltkR), 
                                                    'NULL'>
                                                  )
                                                 >),
                                               hkdf(hkdf(hmac('g'^(~newPrivKey*~respPrivKey),
                                                              'salt_o'),
                                                         h(<
                                                            (<'Algorithms', 'Algorithms', vx, ax>+
                                                             <'Capabilities', 'Capabilities', vx, CR
                                                             >+
                                                             <'Get_Capabilities', 
                                                              'Get_Capabilities', vx, C>+
                                                             <'Get_Version', 'Get_Version', '1'>+
                                                             <'Negotiate_Algorithms', 
                                                              'Negotiate_Algorithms', vx, a1, a2>+
                                                             <'Version', 'Version', v1.1, v2.1>), 
                                                            h(sign(<~oidR, pk(~ltkR)>, ~rootkey)), 
                                                            (<'Finish', 'NULL'>+
                                                             <'Finish_Rsp', 'NULL'>+
                                                             <'Get_Key_Exchange', 
                                                              'Get_Key_Exchange', vx, 
                                                              ~initSessionId, ~nonce, 
                                                              'g'^~newPrivKey>+
                                                             <'Key_Exchange_Resp', 
                                                              'Key_Exchange_Resp', vx, 
                                                              ~respSessionId, 'No_Mutual_auth', 
                                                              ~respNonce, 'g'^~respPrivKey, 
                                                              sign(h(<vx, 
                                                                      'Key_Exchange_Resp_Signing', 
                                                                      (
                                                                       <'Algorithms', 'Algorithms', 
                                                                        vx, ax>+
                                                                       <'Capabilities', 
                                                                        'Capabilities', vx, CR>+
                                                                       <'Get_Capabilities', 
                                                                        'Get_Capabilities', vx, C>+
                                                                       <'Get_Version', 
                                                                        'Get_Version', '1'>+
                                                                       <'Negotiate_Algorithms', 
                                                                        'Negotiate_Algorithms', vx, 
                                                                        a1, a2>+
                                                                       <'Version', 'Version', v1.1, 
                                                                        v2.1>
                                                                      ), 
                                                                      h(sign(<~oidR, pk(~ltkR)>,
                                                                             ~rootkey)), 
                                                                      (<'Finish', 'NULL'>+
                                                                       <'Finish_Rsp', 'NULL'>+
                                                                       <'Get_Key_Exchange', 
                                                                        'Get_Key_Exchange', vx, 
                                                                        ~initSessionId, ~nonce, 
                                                                        'g'^~newPrivKey>+
                                                                       <'Key_Exchange_Resp', 
                                                                        'Key_Exchange_Resp', vx, 
                                                                        ~respSessionId, 
                                                                        'No_Mutual_auth', 
                                                                        ~respNonce, 
                                                                        'g'^~respPrivKey, 'NULL', 
                                                                        'NULL'>
                                                                      )
                                                                     >),
                                                                   ~ltkR), 
                                                              'NULL'>
                                                            )
                                                           >),
                                                         'resp_hs_data'),
                                                    vx, 'finished'))
                                     ) @ #vk.31 )
                                case R_KE_Response
                                solve( !KU( pk(~ltkR) ) @ #vk.51 )
                                  case A_getCertHonest
                                  solve( !KU( 'g'^~newPrivKey ) @ #vk.53 )
                                    case I_KE_Request
                                    solve( !KU( 'g'^~respPrivKey ) @ #vk.34 )
                                      case R_KE_Response
                                      SOLVED // trace found
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  next
                    case R_EncapsResponseAck_RecvCertificate
                    by contradiction /* cyclic */
                  next
                    case R_Spawn_new_PK_Session
                    by contradiction /* cyclic */
                  qed
                next
                  case c_sign
                  by sorry
                qed
              next
                case I_Spawn_new_PK_Session
                by contradiction /* cyclic */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma can_reach_encap_cert_resp [heuristic=S,
                                 hide_lemma=RespOptionLoopBreaker]:
  exists-trace
  "∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #j #j2 #j3 #j4.
    ((((((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                       (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                      (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                     (RespReachVCA( tid2, oid, oidR ) @ #j)) ∧
                    (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2)) ∧
                   (ReceivedEncapsulatedDigest( sid2, tid2, oid, oidR ) @ #j3)) ∧
                  (ReceiveInitCertificate( sid2, tid2, oid, oidR ) @ #j4)) ∧
                 (#i < #i2)) ∧
                (#i2 < #i3)) ∧
               (#j < #j2)) ∧
              (#j2 < #j3)) ∧
             (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
            (¬(∃ #t. StartFinishKE( sid, tid, oid, oidR ) @ #t))) ∧
           (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
             ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
              (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
            ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
             (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
           ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
          ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
           (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
         ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
        ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
       ((ReceivedEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (ReceivedEncapsulatedDigest( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
      ((ReceiveInitCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (ReceiveInitCertificate( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #j #j2 #j3 #j4.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (RespReachVCA( tid2, oid, oidR ) @ #j) ∧
  (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2) ∧
  (ReceivedEncapsulatedDigest( sid2, tid2, oid, oidR ) @ #j3) ∧
  (ReceiveInitCertificate( sid2, tid2, oid, oidR ) @ #j4)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#j < #j2) ∧
  (#j2 < #j3) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ #t. (StartFinishKE( sid, tid, oid, oidR ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceivedEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceivedEncapsulatedDigest( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveInitCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveInitCertificate( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_reach_encap_ack_init [heuristic=C,
                                hide_lemma=RespOptionLoopBreaker]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2 #i3 #i6 #i7 #i8.
    (((((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                      (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                     (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                    (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6)) ∧
                   (SendEncapsulatedCertificate( sid, tid, oid, oidR ) @ #i7)) ∧
                  (StartFinishKEMutualAuth( sid, tid, oid, oidR ) @ #i8)) ∧
                 (#i < #i2)) ∧
                (#i2 < #i3)) ∧
               (#i3 < #i6)) ∧
              (#i6 < #i7)) ∧
             (#i7 < #i8)) ∧
            (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
           (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
             ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
              (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
            ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
             (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
           ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
          ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
           (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
         ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
        ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
       ((SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
      ((SendEncapsulatedCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (SendEncapsulatedCertificate( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2 #i3 #i6 #i7 #i8.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6) ∧
  (SendEncapsulatedCertificate( sid, tid, oid, oidR ) @ #i7) ∧
  (StartFinishKEMutualAuth( sid, tid, oid, oidR ) @ #i8)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#i3 < #i6) ∧
  (#i6 < #i7) ∧
  (#i7 < #i8) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (SendEncapsulatedCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (SendEncapsulatedCertificate( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_reach_end_mutualAuth_resp [heuristic=S,
                                     hide_lemma=ICertOrigin, hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #j #j2 #j3 #j4 #j5.
    ((((((((((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                           (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                          (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                         (RespReachVCA( tid2, oid, oidR ) @ #j)) ∧
                        (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2)) ∧
                       (ReceivedEncapsulatedDigest( sid2, tid2, oid, oidR ) @ #j3)) ∧
                      (ReceiveInitCertificate( sid2, tid2, oid, oidR ) @ #j4)) ∧
                     (RespFinishMutualAuth1( sid2, tid2, oid, oidR ) @ #j5)) ∧
                    (#i < #i2)) ∧
                   (#i2 < #i3)) ∧
                  (#j < #j2)) ∧
                 (#j2 < #j3)) ∧
                (#j3 < #j4)) ∧
               (#j4 < #j5)) ∧
              (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
             (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
               ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
                (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
               (#x = #y))) ∧
            (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
              ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
               (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
              (#x = #y))) ∧
           (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
             ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
              (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
            ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
             (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
           ((StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
          ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
           (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
         ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
        ((ReceivedEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (ReceivedEncapsulatedDigest( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
       ((ReceiveInitCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (ReceiveInitCertificate( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
      ((SendEncapsulatedCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (SendEncapsulatedCertificate( sid2.1, tid2.1, oid2, oidR2
        ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid sid2 tid tid2 oid oidR s1 s2 #i #i2 #i3 #j #j2 #j3 #j4 #j5.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (RespReachVCA( tid2, oid, oidR ) @ #j) ∧
  (SendKEResponse( sid2, tid2, oid, oidR, s2 ) @ #j2) ∧
  (ReceivedEncapsulatedDigest( sid2, tid2, oid, oidR ) @ #j3) ∧
  (ReceiveInitCertificate( sid2, tid2, oid, oidR ) @ #j4) ∧
  (RespFinishMutualAuth1( sid2, tid2, oid, oidR ) @ #j5)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#j < #j2) ∧
  (#j2 < #j3) ∧
  (#j3 < #j4) ∧
  (#j4 < #j5) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1.1 s2.1 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2.1 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceivedEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceivedEncapsulatedDigest( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveInitCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveInitCertificate( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (SendEncapsulatedCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (SendEncapsulatedCertificate( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_reach_end_mutualAuth_init [heuristic=S,
                                     hide_lemma=ICertOrigin, hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid tid oid oidR s1 #i #i2 #i3 #i6 #i7 #i8 #i9.
    (((((((((((((((((((((InitReachVCA( tid, oid, oidR ) @ #i) ∧
                        (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2)) ∧
                       (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3)) ∧
                      (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6)) ∧
                     (SendEncapsulatedCertificate( sid, tid, oid, oidR ) @ #i7)) ∧
                    (StartFinishKEMutualAuth( sid, tid, oid, oidR ) @ #i8)) ∧
                   (InitFinishMutualAuth( sid, tid, oid, oidR ) @ #i9)) ∧
                  (#i < #i2)) ∧
                 (#i2 < #i3)) ∧
                (#i3 < #i6)) ∧
               (#i6 < #i7)) ∧
              (#i7 < #i8)) ∧
             (#i8 < #i9)) ∧
            (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
           (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
             ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
              (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
            ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
             (InitReachVCA( tid2, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
           ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
          ((SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
           (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
         ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
        ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
       ((SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
      ((SendEncapsulatedCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
       (SendEncapsulatedCertificate( sid2, tid2, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid tid oid oidR s1 #i #i2 #i3 #i6 #i7 #i8 #i9.
  (InitReachVCA( tid, oid, oidR ) @ #i) ∧
  (StartKeyExchange( sid, tid, oid, oidR, s1 ) @ #i2) ∧
  (ReceiveKeyExchange( sid, tid, oid, oidR ) @ #i3) ∧
  (SendEncapsulatedDigest( sid, tid, oid, oidR ) @ #i6) ∧
  (SendEncapsulatedCertificate( sid, tid, oid, oidR ) @ #i7) ∧
  (StartFinishKEMutualAuth( sid, tid, oid, oidR ) @ #i8) ∧
  (InitFinishMutualAuth( sid, tid, oid, oidR ) @ #i9)
 ∧
  (#i < #i2) ∧
  (#i2 < #i3) ∧
  (#i3 < #i6) ∧
  (#i6 < #i7) ∧
  (#i7 < #i8) ∧
  (#i8 < #i9) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 oid1 oid2 tid1 tid2 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 s1.1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1.1 ) @ #x) ∧
    (SendKEResponse( sid2, tid2, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (SendEncapsulatedDigest( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (SendEncapsulatedDigest( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2 tid1 tid2 oid1 oid2 oidR1 oidR2 #x #y.
    (SendEncapsulatedCertificate( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (SendEncapsulatedCertificate( sid2, tid2, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_send_receive_message [heuristic=S,
                                hide_lemma=ICertOrigin, hide_lemma=RCertOrigin]:
  exists-trace
  "∃ sid1 sid2 tid1 tid2 oid oidR bindsid cipher #i #j.
    (((((((((((((((((((((((SendMessage( sid1, tid1, oid, oidR, bindsid,
                                        cipher
                           ) @ #i) ∧
                          (ReceiveMessage( sid2, tid2, oid, oidR, bindsid, cipher ) @ #j)) ∧
                         (#i < #j)) ∧
                        (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
                       (¬(∃ sid1.1 tid1.1 oid1 oidR1 #t.
                           RespFinishMutualAuth1( sid1.1, tid1.1, oid1, oidR1 ) @ #t))) ∧
                      (¬(∃ sid1.1 tid1.1 oid1 oidR1 #t.
                          InitFinishMutualAuth( sid1.1, tid1.1, oid1, oidR1 ) @ #t))) ∧
                     (¬(∃ sid1.1 tid1.1 oid1 oidR1 #t.
                         StartFinishKEMutualAuth( sid1.1, tid1.1, oid1, oidR1 ) @ #t))) ∧
                    (¬(∃ sid1.1 tid1.1 kuid1 key1 #t.
                        InitKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t))) ∧
                   (¬(∃ sid1.1 tid1.1 kuid1 key1 #t.
                       RespKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t))) ∧
                  (¬(∃ sid1.1 tid1.1 kuid1 key1 #t.
                      InitPartnerKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t))) ∧
                 (¬(∃ sid1.1 tid1.1 kuid1 key1 #t.
                     RespOwnKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t))) ∧
                (¬(∃ sid1.1 tid1.1 kuid1 key1 key2 #t.
                    InitAllKeyUpdate( sid1.1, tid1.1, kuid1, key1, key2 ) @ #t))) ∧
               (¬(∃ sid1.1 tid1.1 kuid1 key1 key2 #t.
                   RespAllKeyUpdate( sid1.1, tid1.1, kuid1, key1, key2 ) @ #t))) ∧
              (∀ tid1.1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
                ((RespReachVCA( tid1.1, oidI1, oidR1 ) @ #x) ∧
                 (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
                (#x = #y))) ∧
             (∀ tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
               ((InitReachVCA( tid1.1, oid1, oidR1 ) @ #x) ∧
                (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
               (#x = #y))) ∧
            (∀ sid1.1 sid2.1 oid1 oid2 tid1.1 tid2.1 oidR1 oidR2 #x #y.
              ((RStartKEX( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
               (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
              (#x = #y))) ∧
           (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
             ((SendKEResponse( sid1.1, tid1.1, oid1, oidR1, s1 ) @ #x) ∧
              (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
            ((StartFinishKE( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
             (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
           ((IStartKEX( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
            (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
          ((ReceiveKeyExchange( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
           (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
         ((ReceiveFinish( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
          (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x
         #y.
        ((ReceiveMessage( sid1.1, tid1.1, oid1, oidR1, b1, c1 ) @ #x) ∧
         (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x
        #y.
       ((SendMessage( sid1.1, tid1.1, oid1, oidR1, b1, c1 ) @ #x) ∧
        (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
      ((RespFinishMutualAuth1( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
       (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ sid1 sid2 tid1 tid2 oid oidR bindsid cipher #i #j.
  (SendMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #i) ∧
  (ReceiveMessage( sid2, tid2, oid, oidR, bindsid, cipher ) @ #j)
 ∧
  (#i < #j) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 oid1 oidR1 #t.
    (RespFinishMutualAuth1( sid1.1, tid1.1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 oid1 oidR1 #t.
    (InitFinishMutualAuth( sid1.1, tid1.1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 oid1 oidR1 #t.
    (StartFinishKEMutualAuth( sid1.1, tid1.1, oid1, oidR1 ) @ #t)
   ⇒
    ⊥) ∧
  (∀ sid1.1 tid1.1 kuid1 key1 #t.
    (InitKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 kuid1 key1 #t.
    (RespKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 kuid1 key1 #t.
    (InitPartnerKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 kuid1 key1 #t.
    (RespOwnKeyUpdate( sid1.1, tid1.1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 kuid1 key1 key2 #t.
    (InitAllKeyUpdate( sid1.1, tid1.1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1.1 tid1.1 kuid1 key1 key2 #t.
    (RespAllKeyUpdate( sid1.1, tid1.1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1.1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1.1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1.1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 oid1 oid2 tid1.1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
    (SendKEResponse( sid1.1, tid1.1, oid1, oidR1, s1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveFinish( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
    (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x
     #y.
    (ReceiveMessage( sid1.1, tid1.1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x
     #y.
    (SendMessage( sid1.1, tid1.1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1.1 sid2.1 tid1.1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (RespFinishMutualAuth1( sid1.1, tid1.1, oid1, oidR1 ) @ #x) ∧
    (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_keyupdate_init [heuristic=S, hide_lemma=ICertOrigin,
                          hide_lemma=RCertOrigin]:
  exists-trace
  "∃ tid tid2 sid sid2 kuid kuid2 key #i #j.
    (((((((((((((((((((((((((InitKeyUpdate( tid, sid, kuid, key
                             ) @ #i) ∧
                            (RespKeyUpdate( tid2, sid2, kuid2, key ) @ #j)) ∧
                           (#i < #j)) ∧
                          (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
                         (¬(∃ sid1 tid1 oid1 oidR1 #t.
                             RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                        (¬(∃ sid1 tid1 oid1 oidR1 #t.
                            InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                       (¬(∃ sid1 tid1 oid1 oidR1 #t.
                           StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                      (¬(∃ sid1 tid1 oid oidR bindsid cipher #t.
                          SendMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t))) ∧
                     (¬(∃ sid1 tid1 oid oidR bindsid cipher #t.
                         ReceiveMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t))) ∧
                    (¬(∃ sid1 tid1 kuid1 key1 #t.
                        InitPartnerKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                   (¬(∃ sid1 tid1 kuid1 key1 #t.
                       RespOwnKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                  (¬(∃ sid1 tid1 kuid1 key1 key2 #t.
                      InitAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t))) ∧
                 (¬(∃ sid1 tid1 kuid1 key1 key2 #t.
                     RespAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t))) ∧
                (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
                  ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
                   (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
                  (#x = #y))) ∧
               (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
                 ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
                  (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
                 (#x = #y))) ∧
              (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
                ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
                 (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
                (#x = #y))) ∧
             (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
               ((SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
                (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)) ⇒
               (#x = #y))) ∧
            (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
              ((StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
               (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
              (#x = #y))) ∧
           (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
             ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
              (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
            ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
             (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
           ((ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
          ((ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
           (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
         ((SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
          (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
        ((RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
         (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 #x #y.
       ((RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
        (RKEyUpdateVerif( tid2.1, sid2.1, kuid2.1 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 #x #y.
      ((InitKeyUpdate( tid1, sid1, kuid1, k1 ) @ #x) ∧
       (InitKeyUpdate( tid2.1, sid2.1, kuid2.1, k2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ tid tid2 sid sid2 kuid kuid2 key #i #j.
  (InitKeyUpdate( tid, sid, kuid, key ) @ #i) ∧
  (RespKeyUpdate( tid2, sid2, kuid2, key ) @ #j)
 ∧
  (#i < #j) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid oidR bindsid cipher #t.
    (SendMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid oidR bindsid cipher #t.
    (ReceiveMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t)
   ⇒
    ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (InitPartnerKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (RespOwnKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 key2 #t.
    (InitAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 key2 #t.
    (RespAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 #x #y.
    (RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
    (RKEyUpdateVerif( tid2.1, sid2.1, kuid2.1 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 #x #y.
    (InitKeyUpdate( tid1, sid1, kuid1, k1 ) @ #x) ∧
    (InitKeyUpdate( tid2.1, sid2.1, kuid2.1, k2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_keyupdate_resp [heuristic=S, hide_lemma=ICertOrigin,
                          hide_lemma=RCertOrigin]:
  exists-trace
  "∃ tid tid2 sid sid2 kuid kuid2 key #i #j.
    ((((((((((((((((((((((((((RespOwnKeyUpdate( tid, sid, kuid, key
                              ) @ #i) ∧
                             (InitPartnerKeyUpdate( tid2, sid2, kuid2, key ) @ #j)) ∧
                            (#i < #j)) ∧
                           (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
                          (¬(∃ sid1 tid1 oid1 oidR1 #t.
                              RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                         (¬(∃ sid1 tid1 oid1 oidR1 #t.
                             InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                        (¬(∃ sid1 tid1 oid1 oidR1 #t.
                            StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                       (¬(∃ sid1 tid1 oid oidR bindsid cipher #t.
                           SendMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t))) ∧
                      (¬(∃ sid1 tid1 oid oidR bindsid cipher #t.
                          ReceiveMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t))) ∧
                     (¬(∃ sid1 tid1 kuid1 key1 #t.
                         InitKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                    (¬(∃ sid1 tid1 kuid1 key1 #t.
                        RespKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                   (¬(∃ sid1 tid1 kuid1 key1 key2 #t.
                       InitAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t))) ∧
                  (¬(∃ sid1 tid1 kuid1 key1 key2 #t.
                      RespAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t))) ∧
                 (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
                   ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
                    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
                   (#x = #y))) ∧
                (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
                  ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
                   (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
                  (#x = #y))) ∧
               (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
                 ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
                  (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
                 (#x = #y))) ∧
              (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
                ((SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
                 (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)) ⇒
                (#x = #y))) ∧
             (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
               ((StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
                (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
               (#x = #y))) ∧
            (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
              ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
               (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
              (#x = #y))) ∧
           (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
             ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
              (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
            ((ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
             (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
           ((ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
            (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
          ((SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
           (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
         ((RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 #x #y.
        ((RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
         (RKEyUpdateVerif( tid2.1, sid2.1, kuid2.1 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 #x #y.
       ((RespOwnKeyUpdate( tid1, sid1, kuid1, k1 ) @ #x) ∧
        (RespOwnKeyUpdate( tid2.1, sid2.1, kuid2.1, k2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 #x #y.
      ((InitPartnerKeyUpdate( tid1, sid1, kuid1, k1 ) @ #x) ∧
       (InitPartnerKeyUpdate( tid2.1, sid2.1, kuid2.1, k2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ tid tid2 sid sid2 kuid kuid2 key #i #j.
  (RespOwnKeyUpdate( tid, sid, kuid, key ) @ #i) ∧
  (InitPartnerKeyUpdate( tid2, sid2, kuid2, key ) @ #j)
 ∧
  (#i < #j) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid oidR bindsid cipher #t.
    (SendMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid oidR bindsid cipher #t.
    (ReceiveMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t)
   ⇒
    ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (InitKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (RespKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 key2 #t.
    (InitAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 key2 #t.
    (RespAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 #x #y.
    (RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
    (RKEyUpdateVerif( tid2.1, sid2.1, kuid2.1 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 #x #y.
    (RespOwnKeyUpdate( tid1, sid1, kuid1, k1 ) @ #x) ∧
    (RespOwnKeyUpdate( tid2.1, sid2.1, kuid2.1, k2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 #x #y.
    (InitPartnerKeyUpdate( tid1, sid1, kuid1, k1 ) @ #x) ∧
    (InitPartnerKeyUpdate( tid2.1, sid2.1, kuid2.1, k2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_keyupdate_all [heuristic=S, hide_lemma=ICertOrigin,
                         hide_lemma=RCertOrigin]:
  exists-trace
  "∃ tid tid2 sid sid2 kuid kuid2 key1 key2 #i #j.
    ((((((((((((((((((((((((((InitAllKeyUpdate( tid, sid, kuid, key1,
                                                key2
                              ) @ #i) ∧
                             (RespAllKeyUpdate( tid2, sid2, kuid2, key2, key1 ) @ #j)) ∧
                            (#i < #j)) ∧
                           (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
                          (¬(∃ sid1 tid1 oid1 oidR1 #t.
                              RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                         (¬(∃ sid1 tid1 oid1 oidR1 #t.
                             InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                        (¬(∃ sid1 tid1 oid1 oidR1 #t.
                            StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                       (¬(∃ sid1 tid1 oid oidR bindsid cipher #t.
                           SendMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t))) ∧
                      (¬(∃ sid1 tid1 oid oidR bindsid cipher #t.
                          ReceiveMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t))) ∧
                     (¬(∃ sid1 tid1 kuid1 key1.1 #t.
                         InitKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t))) ∧
                    (¬(∃ sid1 tid1 kuid1 key1.1 #t.
                        RespKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t))) ∧
                   (¬(∃ sid1 tid1 kuid1 key1.1 #t.
                       RespOwnKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t))) ∧
                  (¬(∃ sid1 tid1 kuid1 key1.1 #t.
                      InitPartnerKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t))) ∧
                 (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
                   ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
                    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
                   (#x = #y))) ∧
                (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
                  ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
                   (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
                  (#x = #y))) ∧
               (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
                 ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
                  (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
                 (#x = #y))) ∧
              (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
                ((SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
                 (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)) ⇒
                (#x = #y))) ∧
             (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
               ((StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
                (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
               (#x = #y))) ∧
            (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
              ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
               (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
              (#x = #y))) ∧
           (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
             ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
              (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
            ((ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
             (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
           ((ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
            (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
          ((SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
           (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
         ((RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
          (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 #x #y.
        ((RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
         (RKEyUpdateVerif( tid2.1, sid2.1, kuid2.1 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 k3 k4 #x #y.
       ((InitAllKeyUpdate( tid1, sid1, kuid1, k1, k3 ) @ #x) ∧
        (InitAllKeyUpdate( tid2.1, sid2.1, kuid2.1, k2, k4 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 k3 k4 #x #y.
      ((RespAllKeyUpdate( tid1, sid1, kuid1, k1, k3 ) @ #x) ∧
       (RespAllKeyUpdate( tid2.1, sid2.1, kuid2.1, k2, k4 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ tid tid2 sid sid2 kuid kuid2 key1 key2 #i #j.
  (InitAllKeyUpdate( tid, sid, kuid, key1, key2 ) @ #i) ∧
  (RespAllKeyUpdate( tid2, sid2, kuid2, key2, key1 ) @ #j)
 ∧
  (#i < #j) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid oidR bindsid cipher #t.
    (SendMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid oidR bindsid cipher #t.
    (ReceiveMessage( sid1, tid1, oid, oidR, bindsid, cipher ) @ #t)
   ⇒
    ⊥) ∧
  (∀ sid1 tid1 kuid1 key1.1 #t.
    (InitKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1.1 #t.
    (RespKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1.1 #t.
    (RespOwnKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1.1 #t.
    (InitPartnerKeyUpdate( sid1, tid1, kuid1, key1.1 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 #x #y.
    (RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
    (RKEyUpdateVerif( tid2.1, sid2.1, kuid2.1 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 k3 k4 #x #y.
    (InitAllKeyUpdate( tid1, sid1, kuid1, k1, k3 ) @ #x) ∧
    (InitAllKeyUpdate( tid2.1, sid2.1, kuid2.1, k2, k4 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2.1 k1 k2 k3 k4 #x #y.
    (RespAllKeyUpdate( tid1, sid1, kuid1, k1, k3 ) @ #x) ∧
    (RespAllKeyUpdate( tid2.1, sid2.1, kuid2.1, k2, k4 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

lemma can_endsession [heuristic=S, hide_lemma=ICertOrigin,
                      hide_lemma=RCertOrigin]:
  exists-trace
  "∃ tid tid2 sid sid2 oidI oidR #i #j #k.
    ((((((((((((((((((((((((((((StartEndSession( tid, sid, oidI, oidR
                                ) @ #i) ∧
                               (RespEndSession( tid2, sid2, oidI, oidR ) @ #j)) ∧
                              (InitEndSession( tid, sid, oidI, oidR ) @ #k)) ∧
                             (#i < #j)) ∧
                            (#j < #k)) ∧
                           (¬(∃ someoid ltk pk1 #t. Attacker( someoid, ltk, pk1 ) @ #t))) ∧
                          (¬(∃ sid1 tid1 oid1 oidR1 #t.
                              RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                         (¬(∃ sid1 tid1 oid1 oidR1 #t.
                             InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                        (¬(∃ sid1 tid1 oid1 oidR1 #t.
                            StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t))) ∧
                       (¬(∃ sid1 tid1 oid oidR.1 bindsid cipher #t.
                           SendMessage( sid1, tid1, oid, oidR.1, bindsid, cipher ) @ #t))) ∧
                      (¬(∃ sid1 tid1 oid oidR.1 bindsid cipher #t.
                          ReceiveMessage( sid1, tid1, oid, oidR.1, bindsid, cipher
                          ) @ #t))) ∧
                     (¬(∃ sid1 tid1 kuid1 key1 #t.
                         InitKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                    (¬(∃ sid1 tid1 kuid1 key1 #t.
                        RespKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                   (¬(∃ sid1 tid1 kuid1 key1 #t.
                       RespOwnKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                  (¬(∃ sid1 tid1 kuid1 key1 #t.
                      InitPartnerKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t))) ∧
                 (¬(∃ sid1 tid1 kuid1 key1 key2 #t.
                     InitAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t))) ∧
                (¬(∃ sid1 tid1 kuid1 key1 key2 #t.
                    RespAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t))) ∧
               (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
                 ((RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
                  (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)) ⇒
                 (#x = #y))) ∧
              (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
                ((InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
                 (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)) ⇒
                (#x = #y))) ∧
             (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
               ((RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
                (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
               (#x = #y))) ∧
            (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
              ((SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
               (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)) ⇒
              (#x = #y))) ∧
           (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
             ((StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
              (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
             (#x = #y))) ∧
          (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
            ((IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
             (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
            (#x = #y))) ∧
         (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
           ((ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
            (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
           (#x = #y))) ∧
        (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
          ((ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
           (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
          (#x = #y))) ∧
       (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
         ((ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
          (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
         (#x = #y))) ∧
      (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
        ((SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
         (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)) ⇒
        (#x = #y))) ∧
     (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
       ((RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
        (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)) ⇒
       (#x = #y))) ∧
    (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2 #x #y.
      ((RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
       (RKEyUpdateVerif( tid2.1, sid2.1, kuid2 ) @ #y)) ⇒
      (#x = #y))"
/*
guarded formula characterizing all satisfying traces:
"∃ tid tid2 sid sid2 oidI oidR #i #j #k.
  (StartEndSession( tid, sid, oidI, oidR ) @ #i) ∧
  (RespEndSession( tid2, sid2, oidI, oidR ) @ #j) ∧
  (InitEndSession( tid, sid, oidI, oidR ) @ #k)
 ∧
  (#i < #j) ∧
  (#j < #k) ∧
  (∀ someoid ltk pk1 #t. (Attacker( someoid, ltk, pk1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (InitFinishMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid1 oidR1 #t.
    (StartFinishKEMutualAuth( sid1, tid1, oid1, oidR1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 oid oidR.1 bindsid cipher #t.
    (SendMessage( sid1, tid1, oid, oidR.1, bindsid, cipher ) @ #t)
   ⇒
    ⊥) ∧
  (∀ sid1 tid1 oid oidR.1 bindsid cipher #t.
    (ReceiveMessage( sid1, tid1, oid, oidR.1, bindsid, cipher ) @ #t)
   ⇒
    ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (InitKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (RespKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (RespOwnKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 #t.
    (InitPartnerKeyUpdate( sid1, tid1, kuid1, key1 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 key2 #t.
    (InitAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ sid1 tid1 kuid1 key1 key2 #t.
    (RespAllKeyUpdate( sid1, tid1, kuid1, key1, key2 ) @ #t) ⇒ ⊥) ∧
  (∀ tid1 tid2.1 oidI1 oidI2 oidR1 oidR2 #x #y.
    (RespReachVCA( tid1, oidI1, oidR1 ) @ #x) ∧
    (RespReachVCA( tid2.1, oidI2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (InitReachVCA( tid1, oid1, oidR1 ) @ #x) ∧
    (InitReachVCA( tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 oid1 oid2 tid1 tid2.1 oidR1 oidR2 #x #y.
    (RStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 s1 s2 #x #y.
    (SendKEResponse( sid1, tid1, oid1, oidR1, s1 ) @ #x) ∧
    (SendKEResponse( sid2.1, tid2.1, oid2, oidR2, s2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (StartFinishKE( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (StartFinishKE( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (IStartKEX( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (IStartKEX( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveKeyExchange( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveKeyExchange( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (ReceiveFinish( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (ReceiveFinish( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (ReceiveMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (ReceiveMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 b1 b2 c1 c2 #x #y.
    (SendMessage( sid1, tid1, oid1, oidR1, b1, c1 ) @ #x) ∧
    (SendMessage( sid2.1, tid2.1, oid2, oidR2, b2, c2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ sid1 sid2.1 tid1 tid2.1 oid1 oid2 oidR1 oidR2 #x #y.
    (RespFinishMutualAuth1( sid1, tid1, oid1, oidR1 ) @ #x) ∧
    (RespFinishMutualAuth1( sid2.1, tid2.1, oid2, oidR2 ) @ #y)
   ⇒
    #x = #y) ∧
  (∀ tid1 tid2.1 sid1 sid2.1 kuid1 kuid2 #x #y.
    (RKEyUpdateVerif( tid1, sid1, kuid1 ) @ #x) ∧
    (RKEyUpdateVerif( tid2.1, sid2.1, kuid2 ) @ #y)
   ⇒
    #x = #y)"
*/
by sorry

/* All well-formedness checks were successful. */

end